// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-management.proto

#ifndef PROTOBUF_messages_2dmanagement_2eproto__INCLUDED
#define PROTOBUF_messages_2dmanagement_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "messages-common.pb.h"
// @@protoc_insertion_point(includes)

namespace hw {
namespace trezor {
namespace messages {
namespace management {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2dmanagement_2eproto();
void protobuf_AssignDesc_messages_2dmanagement_2eproto();
void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

class Initialize;
class GetFeatures;
class Features;
class ClearSession;
class ApplySettings;
class ApplyFlags;
class ChangePin;
class Ping;
class Cancel;
class GetEntropy;
class Entropy;
class WipeDevice;
class LoadDevice;
class ResetDevice;
class BackupDevice;
class EntropyRequest;
class EntropyAck;
class RecoveryDevice;
class WordRequest;
class WordAck;
class SetU2FCounter;

enum ApplySettings_PassphraseSourceType {
  ApplySettings_PassphraseSourceType_ASK = 0,
  ApplySettings_PassphraseSourceType_DEVICE = 1,
  ApplySettings_PassphraseSourceType_HOST = 2
};
bool ApplySettings_PassphraseSourceType_IsValid(int value);
const ApplySettings_PassphraseSourceType ApplySettings_PassphraseSourceType_PassphraseSourceType_MIN = ApplySettings_PassphraseSourceType_ASK;
const ApplySettings_PassphraseSourceType ApplySettings_PassphraseSourceType_PassphraseSourceType_MAX = ApplySettings_PassphraseSourceType_HOST;
const int ApplySettings_PassphraseSourceType_PassphraseSourceType_ARRAYSIZE = ApplySettings_PassphraseSourceType_PassphraseSourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ApplySettings_PassphraseSourceType_descriptor();
inline const ::std::string& ApplySettings_PassphraseSourceType_Name(ApplySettings_PassphraseSourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ApplySettings_PassphraseSourceType_descriptor(), value);
}
inline bool ApplySettings_PassphraseSourceType_Parse(
    const ::std::string& name, ApplySettings_PassphraseSourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ApplySettings_PassphraseSourceType>(
    ApplySettings_PassphraseSourceType_descriptor(), name, value);
}
enum RecoveryDevice_RecoveryDeviceType {
  RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords = 0,
  RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix = 1
};
bool RecoveryDevice_RecoveryDeviceType_IsValid(int value);
const RecoveryDevice_RecoveryDeviceType RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MIN = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords;
const RecoveryDevice_RecoveryDeviceType RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix;
const int RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ARRAYSIZE = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecoveryDevice_RecoveryDeviceType_descriptor();
inline const ::std::string& RecoveryDevice_RecoveryDeviceType_Name(RecoveryDevice_RecoveryDeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecoveryDevice_RecoveryDeviceType_descriptor(), value);
}
inline bool RecoveryDevice_RecoveryDeviceType_Parse(
    const ::std::string& name, RecoveryDevice_RecoveryDeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecoveryDevice_RecoveryDeviceType>(
    RecoveryDevice_RecoveryDeviceType_descriptor(), name, value);
}
enum WordRequest_WordRequestType {
  WordRequest_WordRequestType_WordRequestType_Plain = 0,
  WordRequest_WordRequestType_WordRequestType_Matrix9 = 1,
  WordRequest_WordRequestType_WordRequestType_Matrix6 = 2
};
bool WordRequest_WordRequestType_IsValid(int value);
const WordRequest_WordRequestType WordRequest_WordRequestType_WordRequestType_MIN = WordRequest_WordRequestType_WordRequestType_Plain;
const WordRequest_WordRequestType WordRequest_WordRequestType_WordRequestType_MAX = WordRequest_WordRequestType_WordRequestType_Matrix6;
const int WordRequest_WordRequestType_WordRequestType_ARRAYSIZE = WordRequest_WordRequestType_WordRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WordRequest_WordRequestType_descriptor();
inline const ::std::string& WordRequest_WordRequestType_Name(WordRequest_WordRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WordRequest_WordRequestType_descriptor(), value);
}
inline bool WordRequest_WordRequestType_Parse(
    const ::std::string& name, WordRequest_WordRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WordRequest_WordRequestType>(
    WordRequest_WordRequestType_descriptor(), name, value);
}
// ===================================================================

class Initialize : public ::google::protobuf::Message {
 public:
  Initialize();
  virtual ~Initialize();

  Initialize(const Initialize& from);

  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Initialize& default_instance();

  void Swap(Initialize* other);

  // implements Message ----------------------------------------------

  Initialize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Initialize& from);
  void MergeFrom(const Initialize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const void* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional bool skip_passphrase = 2;
  inline bool has_skip_passphrase() const;
  inline void clear_skip_passphrase();
  static const int kSkipPassphraseFieldNumber = 2;
  inline bool skip_passphrase() const;
  inline void set_skip_passphrase(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Initialize)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_skip_passphrase();
  inline void clear_has_skip_passphrase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* state_;
  bool skip_passphrase_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static Initialize* default_instance_;
};
// -------------------------------------------------------------------

class GetFeatures : public ::google::protobuf::Message {
 public:
  GetFeatures();
  virtual ~GetFeatures();

  GetFeatures(const GetFeatures& from);

  inline GetFeatures& operator=(const GetFeatures& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFeatures& default_instance();

  void Swap(GetFeatures* other);

  // implements Message ----------------------------------------------

  GetFeatures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFeatures& from);
  void MergeFrom(const GetFeatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetFeatures)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static GetFeatures* default_instance_;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  void Swap(Features* other);

  // implements Message ----------------------------------------------

  Features* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vendor = 1;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 1;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional uint32 major_version = 2;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 major_version() const;
  inline void set_major_version(::google::protobuf::uint32 value);

  // optional uint32 minor_version = 3;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 minor_version() const;
  inline void set_minor_version(::google::protobuf::uint32 value);

  // optional uint32 patch_version = 4;
  inline bool has_patch_version() const;
  inline void clear_patch_version();
  static const int kPatchVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 patch_version() const;
  inline void set_patch_version(::google::protobuf::uint32 value);

  // optional bool bootloader_mode = 5;
  inline bool has_bootloader_mode() const;
  inline void clear_bootloader_mode();
  static const int kBootloaderModeFieldNumber = 5;
  inline bool bootloader_mode() const;
  inline void set_bootloader_mode(bool value);

  // optional string device_id = 6;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional bool pin_protection = 7;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 7;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional bool passphrase_protection = 8;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 8;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional string language = 9;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 9;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 10;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 10;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool initialized = 12;
  inline bool has_initialized() const;
  inline void clear_initialized();
  static const int kInitializedFieldNumber = 12;
  inline bool initialized() const;
  inline void set_initialized(bool value);

  // optional bytes revision = 13;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 13;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const void* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // optional bytes bootloader_hash = 14;
  inline bool has_bootloader_hash() const;
  inline void clear_bootloader_hash();
  static const int kBootloaderHashFieldNumber = 14;
  inline const ::std::string& bootloader_hash() const;
  inline void set_bootloader_hash(const ::std::string& value);
  inline void set_bootloader_hash(const char* value);
  inline void set_bootloader_hash(const void* value, size_t size);
  inline ::std::string* mutable_bootloader_hash();
  inline ::std::string* release_bootloader_hash();
  inline void set_allocated_bootloader_hash(::std::string* bootloader_hash);

  // optional bool imported = 15;
  inline bool has_imported() const;
  inline void clear_imported();
  static const int kImportedFieldNumber = 15;
  inline bool imported() const;
  inline void set_imported(bool value);

  // optional bool pin_cached = 16;
  inline bool has_pin_cached() const;
  inline void clear_pin_cached();
  static const int kPinCachedFieldNumber = 16;
  inline bool pin_cached() const;
  inline void set_pin_cached(bool value);

  // optional bool passphrase_cached = 17;
  inline bool has_passphrase_cached() const;
  inline void clear_passphrase_cached();
  static const int kPassphraseCachedFieldNumber = 17;
  inline bool passphrase_cached() const;
  inline void set_passphrase_cached(bool value);

  // optional bool firmware_present = 18;
  inline bool has_firmware_present() const;
  inline void clear_firmware_present();
  static const int kFirmwarePresentFieldNumber = 18;
  inline bool firmware_present() const;
  inline void set_firmware_present(bool value);

  // optional bool needs_backup = 19;
  inline bool has_needs_backup() const;
  inline void clear_needs_backup();
  static const int kNeedsBackupFieldNumber = 19;
  inline bool needs_backup() const;
  inline void set_needs_backup(bool value);

  // optional uint32 flags = 20;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 20;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional string model = 21;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 21;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional uint32 fw_major = 22;
  inline bool has_fw_major() const;
  inline void clear_fw_major();
  static const int kFwMajorFieldNumber = 22;
  inline ::google::protobuf::uint32 fw_major() const;
  inline void set_fw_major(::google::protobuf::uint32 value);

  // optional uint32 fw_minor = 23;
  inline bool has_fw_minor() const;
  inline void clear_fw_minor();
  static const int kFwMinorFieldNumber = 23;
  inline ::google::protobuf::uint32 fw_minor() const;
  inline void set_fw_minor(::google::protobuf::uint32 value);

  // optional uint32 fw_patch = 24;
  inline bool has_fw_patch() const;
  inline void clear_fw_patch();
  static const int kFwPatchFieldNumber = 24;
  inline ::google::protobuf::uint32 fw_patch() const;
  inline void set_fw_patch(::google::protobuf::uint32 value);

  // optional string fw_vendor = 25;
  inline bool has_fw_vendor() const;
  inline void clear_fw_vendor();
  static const int kFwVendorFieldNumber = 25;
  inline const ::std::string& fw_vendor() const;
  inline void set_fw_vendor(const ::std::string& value);
  inline void set_fw_vendor(const char* value);
  inline void set_fw_vendor(const char* value, size_t size);
  inline ::std::string* mutable_fw_vendor();
  inline ::std::string* release_fw_vendor();
  inline void set_allocated_fw_vendor(::std::string* fw_vendor);

  // optional bytes fw_vendor_keys = 26;
  inline bool has_fw_vendor_keys() const;
  inline void clear_fw_vendor_keys();
  static const int kFwVendorKeysFieldNumber = 26;
  inline const ::std::string& fw_vendor_keys() const;
  inline void set_fw_vendor_keys(const ::std::string& value);
  inline void set_fw_vendor_keys(const char* value);
  inline void set_fw_vendor_keys(const void* value, size_t size);
  inline ::std::string* mutable_fw_vendor_keys();
  inline ::std::string* release_fw_vendor_keys();
  inline void set_allocated_fw_vendor_keys(::std::string* fw_vendor_keys);

  // optional bool unfinished_backup = 27;
  inline bool has_unfinished_backup() const;
  inline void clear_unfinished_backup();
  static const int kUnfinishedBackupFieldNumber = 27;
  inline bool unfinished_backup() const;
  inline void set_unfinished_backup(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Features)
 private:
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_patch_version();
  inline void clear_has_patch_version();
  inline void set_has_bootloader_mode();
  inline void clear_has_bootloader_mode();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_initialized();
  inline void clear_has_initialized();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_bootloader_hash();
  inline void clear_has_bootloader_hash();
  inline void set_has_imported();
  inline void clear_has_imported();
  inline void set_has_pin_cached();
  inline void clear_has_pin_cached();
  inline void set_has_passphrase_cached();
  inline void clear_has_passphrase_cached();
  inline void set_has_firmware_present();
  inline void clear_has_firmware_present();
  inline void set_has_needs_backup();
  inline void clear_has_needs_backup();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_fw_major();
  inline void clear_has_fw_major();
  inline void set_has_fw_minor();
  inline void clear_has_fw_minor();
  inline void set_has_fw_patch();
  inline void clear_has_fw_patch();
  inline void set_has_fw_vendor();
  inline void clear_has_fw_vendor();
  inline void set_has_fw_vendor_keys();
  inline void clear_has_fw_vendor_keys();
  inline void set_has_unfinished_backup();
  inline void clear_has_unfinished_backup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* vendor_;
  ::google::protobuf::uint32 major_version_;
  ::google::protobuf::uint32 minor_version_;
  ::std::string* device_id_;
  ::google::protobuf::uint32 patch_version_;
  bool bootloader_mode_;
  bool pin_protection_;
  bool passphrase_protection_;
  bool initialized_;
  ::std::string* language_;
  ::std::string* label_;
  ::std::string* revision_;
  ::std::string* bootloader_hash_;
  bool imported_;
  bool pin_cached_;
  bool passphrase_cached_;
  bool firmware_present_;
  ::google::protobuf::uint32 flags_;
  ::std::string* model_;
  ::google::protobuf::uint32 fw_major_;
  ::google::protobuf::uint32 fw_minor_;
  bool needs_backup_;
  bool unfinished_backup_;
  ::google::protobuf::uint32 fw_patch_;
  ::std::string* fw_vendor_;
  ::std::string* fw_vendor_keys_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static Features* default_instance_;
};
// -------------------------------------------------------------------

class ClearSession : public ::google::protobuf::Message {
 public:
  ClearSession();
  virtual ~ClearSession();

  ClearSession(const ClearSession& from);

  inline ClearSession& operator=(const ClearSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearSession& default_instance();

  void Swap(ClearSession* other);

  // implements Message ----------------------------------------------

  ClearSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClearSession& from);
  void MergeFrom(const ClearSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ClearSession)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static ClearSession* default_instance_;
};
// -------------------------------------------------------------------

class ApplySettings : public ::google::protobuf::Message {
 public:
  ApplySettings();
  virtual ~ApplySettings();

  ApplySettings(const ApplySettings& from);

  inline ApplySettings& operator=(const ApplySettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplySettings& default_instance();

  void Swap(ApplySettings* other);

  // implements Message ----------------------------------------------

  ApplySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplySettings& from);
  void MergeFrom(const ApplySettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ApplySettings_PassphraseSourceType PassphraseSourceType;
  static const PassphraseSourceType ASK = ApplySettings_PassphraseSourceType_ASK;
  static const PassphraseSourceType DEVICE = ApplySettings_PassphraseSourceType_DEVICE;
  static const PassphraseSourceType HOST = ApplySettings_PassphraseSourceType_HOST;
  static inline bool PassphraseSourceType_IsValid(int value) {
    return ApplySettings_PassphraseSourceType_IsValid(value);
  }
  static const PassphraseSourceType PassphraseSourceType_MIN =
    ApplySettings_PassphraseSourceType_PassphraseSourceType_MIN;
  static const PassphraseSourceType PassphraseSourceType_MAX =
    ApplySettings_PassphraseSourceType_PassphraseSourceType_MAX;
  static const int PassphraseSourceType_ARRAYSIZE =
    ApplySettings_PassphraseSourceType_PassphraseSourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PassphraseSourceType_descriptor() {
    return ApplySettings_PassphraseSourceType_descriptor();
  }
  static inline const ::std::string& PassphraseSourceType_Name(PassphraseSourceType value) {
    return ApplySettings_PassphraseSourceType_Name(value);
  }
  static inline bool PassphraseSourceType_Parse(const ::std::string& name,
      PassphraseSourceType* value) {
    return ApplySettings_PassphraseSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string language = 1;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool use_passphrase = 3;
  inline bool has_use_passphrase() const;
  inline void clear_use_passphrase();
  static const int kUsePassphraseFieldNumber = 3;
  inline bool use_passphrase() const;
  inline void set_use_passphrase(bool value);

  // optional bytes homescreen = 4;
  inline bool has_homescreen() const;
  inline void clear_homescreen();
  static const int kHomescreenFieldNumber = 4;
  inline const ::std::string& homescreen() const;
  inline void set_homescreen(const ::std::string& value);
  inline void set_homescreen(const char* value);
  inline void set_homescreen(const void* value, size_t size);
  inline ::std::string* mutable_homescreen();
  inline ::std::string* release_homescreen();
  inline void set_allocated_homescreen(::std::string* homescreen);

  // optional .hw.trezor.messages.management.ApplySettings.PassphraseSourceType passphrase_source = 5;
  inline bool has_passphrase_source() const;
  inline void clear_passphrase_source();
  static const int kPassphraseSourceFieldNumber = 5;
  inline ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType passphrase_source() const;
  inline void set_passphrase_source(::hw::trezor::messages::management::ApplySettings_PassphraseSourceType value);

  // optional uint32 auto_lock_delay_ms = 6;
  inline bool has_auto_lock_delay_ms() const;
  inline void clear_auto_lock_delay_ms();
  static const int kAutoLockDelayMsFieldNumber = 6;
  inline ::google::protobuf::uint32 auto_lock_delay_ms() const;
  inline void set_auto_lock_delay_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ApplySettings)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_use_passphrase();
  inline void clear_has_use_passphrase();
  inline void set_has_homescreen();
  inline void clear_has_homescreen();
  inline void set_has_passphrase_source();
  inline void clear_has_passphrase_source();
  inline void set_has_auto_lock_delay_ms();
  inline void clear_has_auto_lock_delay_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* language_;
  ::std::string* label_;
  ::std::string* homescreen_;
  bool use_passphrase_;
  int passphrase_source_;
  ::google::protobuf::uint32 auto_lock_delay_ms_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static ApplySettings* default_instance_;
};
// -------------------------------------------------------------------

class ApplyFlags : public ::google::protobuf::Message {
 public:
  ApplyFlags();
  virtual ~ApplyFlags();

  ApplyFlags(const ApplyFlags& from);

  inline ApplyFlags& operator=(const ApplyFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyFlags& default_instance();

  void Swap(ApplyFlags* other);

  // implements Message ----------------------------------------------

  ApplyFlags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyFlags& from);
  void MergeFrom(const ApplyFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ApplyFlags)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 flags_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static ApplyFlags* default_instance_;
};
// -------------------------------------------------------------------

class ChangePin : public ::google::protobuf::Message {
 public:
  ChangePin();
  virtual ~ChangePin();

  ChangePin(const ChangePin& from);

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePin& default_instance();

  void Swap(ChangePin* other);

  // implements Message ----------------------------------------------

  ChangePin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePin& from);
  void MergeFrom(const ChangePin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool remove = 1;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 1;
  inline bool remove() const;
  inline void set_remove(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ChangePin)
 private:
  inline void set_has_remove();
  inline void clear_has_remove();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool remove_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static ChangePin* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool button_protection = 2;
  inline bool has_button_protection() const;
  inline void clear_button_protection();
  static const int kButtonProtectionFieldNumber = 2;
  inline bool button_protection() const;
  inline void set_button_protection(bool value);

  // optional bool pin_protection = 3;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional bool passphrase_protection = 4;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Ping)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_button_protection();
  inline void clear_has_button_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* message_;
  bool button_protection_;
  bool pin_protection_;
  bool passphrase_protection_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Cancel : public ::google::protobuf::Message {
 public:
  Cancel();
  virtual ~Cancel();

  Cancel(const Cancel& from);

  inline Cancel& operator=(const Cancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cancel& default_instance();

  void Swap(Cancel* other);

  // implements Message ----------------------------------------------

  Cancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cancel& from);
  void MergeFrom(const Cancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Cancel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static Cancel* default_instance_;
};
// -------------------------------------------------------------------

class GetEntropy : public ::google::protobuf::Message {
 public:
  GetEntropy();
  virtual ~GetEntropy();

  GetEntropy(const GetEntropy& from);

  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEntropy& default_instance();

  void Swap(GetEntropy* other);

  // implements Message ----------------------------------------------

  GetEntropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEntropy& from);
  void MergeFrom(const GetEntropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.GetEntropy)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static GetEntropy* default_instance_;
};
// -------------------------------------------------------------------

class Entropy : public ::google::protobuf::Message {
 public:
  Entropy();
  virtual ~Entropy();

  Entropy(const Entropy& from);

  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entropy& default_instance();

  void Swap(Entropy* other);

  // implements Message ----------------------------------------------

  Entropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entropy& from);
  void MergeFrom(const Entropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  inline void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.Entropy)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* entropy_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static Entropy* default_instance_;
};
// -------------------------------------------------------------------

class WipeDevice : public ::google::protobuf::Message {
 public:
  WipeDevice();
  virtual ~WipeDevice();

  WipeDevice(const WipeDevice& from);

  inline WipeDevice& operator=(const WipeDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WipeDevice& default_instance();

  void Swap(WipeDevice* other);

  // implements Message ----------------------------------------------

  WipeDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WipeDevice& from);
  void MergeFrom(const WipeDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WipeDevice)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static WipeDevice* default_instance_;
};
// -------------------------------------------------------------------

class LoadDevice : public ::google::protobuf::Message {
 public:
  LoadDevice();
  virtual ~LoadDevice();

  LoadDevice(const LoadDevice& from);

  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDevice& default_instance();

  void Swap(LoadDevice* other);

  // implements Message ----------------------------------------------

  LoadDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadDevice& from);
  void MergeFrom(const LoadDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mnemonic = 1;
  inline bool has_mnemonic() const;
  inline void clear_mnemonic();
  static const int kMnemonicFieldNumber = 1;
  inline const ::std::string& mnemonic() const;
  inline void set_mnemonic(const ::std::string& value);
  inline void set_mnemonic(const char* value);
  inline void set_mnemonic(const char* value, size_t size);
  inline ::std::string* mutable_mnemonic();
  inline ::std::string* release_mnemonic();
  inline void set_allocated_mnemonic(::std::string* mnemonic);

  // optional .hw.trezor.messages.common.HDNodeType node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::hw::trezor::messages::common::HDNodeType& node() const;
  inline ::hw::trezor::messages::common::HDNodeType* mutable_node();
  inline ::hw::trezor::messages::common::HDNodeType* release_node();
  inline void set_allocated_node(::hw::trezor::messages::common::HDNodeType* node);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional bool passphrase_protection = 4;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional string language = 5 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 5;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool skip_checksum = 7;
  inline bool has_skip_checksum() const;
  inline void clear_skip_checksum();
  static const int kSkipChecksumFieldNumber = 7;
  inline bool skip_checksum() const;
  inline void set_skip_checksum(bool value);

  // optional uint32 u2f_counter = 8;
  inline bool has_u2f_counter() const;
  inline void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 8;
  inline ::google::protobuf::uint32 u2f_counter() const;
  inline void set_u2f_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.LoadDevice)
 private:
  inline void set_has_mnemonic();
  inline void clear_has_mnemonic();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_skip_checksum();
  inline void clear_has_skip_checksum();
  inline void set_has_u2f_counter();
  inline void clear_has_u2f_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mnemonic_;
  ::hw::trezor::messages::common::HDNodeType* node_;
  ::std::string* pin_;
  static ::std::string* _default_language_;
  ::std::string* language_;
  ::std::string* label_;
  bool passphrase_protection_;
  bool skip_checksum_;
  ::google::protobuf::uint32 u2f_counter_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static LoadDevice* default_instance_;
};
// -------------------------------------------------------------------

class ResetDevice : public ::google::protobuf::Message {
 public:
  ResetDevice();
  virtual ~ResetDevice();

  ResetDevice(const ResetDevice& from);

  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetDevice& default_instance();

  void Swap(ResetDevice* other);

  // implements Message ----------------------------------------------

  ResetDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetDevice& from);
  void MergeFrom(const ResetDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool display_random = 1;
  inline bool has_display_random() const;
  inline void clear_display_random();
  static const int kDisplayRandomFieldNumber = 1;
  inline bool display_random() const;
  inline void set_display_random(bool value);

  // optional uint32 strength = 2 [default = 256];
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 2;
  inline ::google::protobuf::uint32 strength() const;
  inline void set_strength(::google::protobuf::uint32 value);

  // optional bool passphrase_protection = 3;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 3;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional bool pin_protection = 4;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 4;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional string language = 5 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 5;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional uint32 u2f_counter = 7;
  inline bool has_u2f_counter() const;
  inline void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 7;
  inline ::google::protobuf::uint32 u2f_counter() const;
  inline void set_u2f_counter(::google::protobuf::uint32 value);

  // optional bool skip_backup = 8;
  inline bool has_skip_backup() const;
  inline void clear_skip_backup();
  static const int kSkipBackupFieldNumber = 8;
  inline bool skip_backup() const;
  inline void set_skip_backup(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.ResetDevice)
 private:
  inline void set_has_display_random();
  inline void clear_has_display_random();
  inline void set_has_strength();
  inline void clear_has_strength();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_u2f_counter();
  inline void clear_has_u2f_counter();
  inline void set_has_skip_backup();
  inline void clear_has_skip_backup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 strength_;
  bool display_random_;
  bool passphrase_protection_;
  bool pin_protection_;
  bool skip_backup_;
  static ::std::string* _default_language_;
  ::std::string* language_;
  ::std::string* label_;
  ::google::protobuf::uint32 u2f_counter_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static ResetDevice* default_instance_;
};
// -------------------------------------------------------------------

class BackupDevice : public ::google::protobuf::Message {
 public:
  BackupDevice();
  virtual ~BackupDevice();

  BackupDevice(const BackupDevice& from);

  inline BackupDevice& operator=(const BackupDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupDevice& default_instance();

  void Swap(BackupDevice* other);

  // implements Message ----------------------------------------------

  BackupDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackupDevice& from);
  void MergeFrom(const BackupDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.BackupDevice)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static BackupDevice* default_instance_;
};
// -------------------------------------------------------------------

class EntropyRequest : public ::google::protobuf::Message {
 public:
  EntropyRequest();
  virtual ~EntropyRequest();

  EntropyRequest(const EntropyRequest& from);

  inline EntropyRequest& operator=(const EntropyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyRequest& default_instance();

  void Swap(EntropyRequest* other);

  // implements Message ----------------------------------------------

  EntropyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntropyRequest& from);
  void MergeFrom(const EntropyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.EntropyRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static EntropyRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntropyAck : public ::google::protobuf::Message {
 public:
  EntropyAck();
  virtual ~EntropyAck();

  EntropyAck(const EntropyAck& from);

  inline EntropyAck& operator=(const EntropyAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyAck& default_instance();

  void Swap(EntropyAck* other);

  // implements Message ----------------------------------------------

  EntropyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntropyAck& from);
  void MergeFrom(const EntropyAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  inline void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.EntropyAck)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* entropy_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static EntropyAck* default_instance_;
};
// -------------------------------------------------------------------

class RecoveryDevice : public ::google::protobuf::Message {
 public:
  RecoveryDevice();
  virtual ~RecoveryDevice();

  RecoveryDevice(const RecoveryDevice& from);

  inline RecoveryDevice& operator=(const RecoveryDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecoveryDevice& default_instance();

  void Swap(RecoveryDevice* other);

  // implements Message ----------------------------------------------

  RecoveryDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecoveryDevice& from);
  void MergeFrom(const RecoveryDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RecoveryDevice_RecoveryDeviceType RecoveryDeviceType;
  static const RecoveryDeviceType RecoveryDeviceType_ScrambledWords = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ScrambledWords;
  static const RecoveryDeviceType RecoveryDeviceType_Matrix = RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_Matrix;
  static inline bool RecoveryDeviceType_IsValid(int value) {
    return RecoveryDevice_RecoveryDeviceType_IsValid(value);
  }
  static const RecoveryDeviceType RecoveryDeviceType_MIN =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MIN;
  static const RecoveryDeviceType RecoveryDeviceType_MAX =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_MAX;
  static const int RecoveryDeviceType_ARRAYSIZE =
    RecoveryDevice_RecoveryDeviceType_RecoveryDeviceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RecoveryDeviceType_descriptor() {
    return RecoveryDevice_RecoveryDeviceType_descriptor();
  }
  static inline const ::std::string& RecoveryDeviceType_Name(RecoveryDeviceType value) {
    return RecoveryDevice_RecoveryDeviceType_Name(value);
  }
  static inline bool RecoveryDeviceType_Parse(const ::std::string& name,
      RecoveryDeviceType* value) {
    return RecoveryDevice_RecoveryDeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 word_count = 1;
  inline bool has_word_count() const;
  inline void clear_word_count();
  static const int kWordCountFieldNumber = 1;
  inline ::google::protobuf::uint32 word_count() const;
  inline void set_word_count(::google::protobuf::uint32 value);

  // optional bool passphrase_protection = 2;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 2;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional bool pin_protection = 3;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional string language = 4 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 4;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool enforce_wordlist = 6;
  inline bool has_enforce_wordlist() const;
  inline void clear_enforce_wordlist();
  static const int kEnforceWordlistFieldNumber = 6;
  inline bool enforce_wordlist() const;
  inline void set_enforce_wordlist(bool value);

  // optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType type() const;
  inline void set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value);

  // optional uint32 u2f_counter = 9;
  inline bool has_u2f_counter() const;
  inline void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 9;
  inline ::google::protobuf::uint32 u2f_counter() const;
  inline void set_u2f_counter(::google::protobuf::uint32 value);

  // optional bool dry_run = 10;
  inline bool has_dry_run() const;
  inline void clear_dry_run();
  static const int kDryRunFieldNumber = 10;
  inline bool dry_run() const;
  inline void set_dry_run(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.RecoveryDevice)
 private:
  inline void set_has_word_count();
  inline void clear_has_word_count();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_enforce_wordlist();
  inline void clear_has_enforce_wordlist();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_u2f_counter();
  inline void clear_has_u2f_counter();
  inline void set_has_dry_run();
  inline void clear_has_dry_run();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_language_;
  ::std::string* language_;
  ::google::protobuf::uint32 word_count_;
  bool passphrase_protection_;
  bool pin_protection_;
  bool enforce_wordlist_;
  bool dry_run_;
  ::std::string* label_;
  int type_;
  ::google::protobuf::uint32 u2f_counter_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static RecoveryDevice* default_instance_;
};
// -------------------------------------------------------------------

class WordRequest : public ::google::protobuf::Message {
 public:
  WordRequest();
  virtual ~WordRequest();

  WordRequest(const WordRequest& from);

  inline WordRequest& operator=(const WordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordRequest& default_instance();

  void Swap(WordRequest* other);

  // implements Message ----------------------------------------------

  WordRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordRequest& from);
  void MergeFrom(const WordRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef WordRequest_WordRequestType WordRequestType;
  static const WordRequestType WordRequestType_Plain = WordRequest_WordRequestType_WordRequestType_Plain;
  static const WordRequestType WordRequestType_Matrix9 = WordRequest_WordRequestType_WordRequestType_Matrix9;
  static const WordRequestType WordRequestType_Matrix6 = WordRequest_WordRequestType_WordRequestType_Matrix6;
  static inline bool WordRequestType_IsValid(int value) {
    return WordRequest_WordRequestType_IsValid(value);
  }
  static const WordRequestType WordRequestType_MIN =
    WordRequest_WordRequestType_WordRequestType_MIN;
  static const WordRequestType WordRequestType_MAX =
    WordRequest_WordRequestType_WordRequestType_MAX;
  static const int WordRequestType_ARRAYSIZE =
    WordRequest_WordRequestType_WordRequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WordRequestType_descriptor() {
    return WordRequest_WordRequestType_descriptor();
  }
  static inline const ::std::string& WordRequestType_Name(WordRequestType value) {
    return WordRequest_WordRequestType_Name(value);
  }
  static inline bool WordRequestType_Parse(const ::std::string& name,
      WordRequestType* value) {
    return WordRequest_WordRequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::hw::trezor::messages::management::WordRequest_WordRequestType type() const;
  inline void set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WordRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static WordRequest* default_instance_;
};
// -------------------------------------------------------------------

class WordAck : public ::google::protobuf::Message {
 public:
  WordAck();
  virtual ~WordAck();

  WordAck(const WordAck& from);

  inline WordAck& operator=(const WordAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordAck& default_instance();

  void Swap(WordAck* other);

  // implements Message ----------------------------------------------

  WordAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordAck& from);
  void MergeFrom(const WordAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.WordAck)
 private:
  inline void set_has_word();
  inline void clear_has_word();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* word_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static WordAck* default_instance_;
};
// -------------------------------------------------------------------

class SetU2FCounter : public ::google::protobuf::Message {
 public:
  SetU2FCounter();
  virtual ~SetU2FCounter();

  SetU2FCounter(const SetU2FCounter& from);

  inline SetU2FCounter& operator=(const SetU2FCounter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetU2FCounter& default_instance();

  void Swap(SetU2FCounter* other);

  // implements Message ----------------------------------------------

  SetU2FCounter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetU2FCounter& from);
  void MergeFrom(const SetU2FCounter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 u2f_counter = 1;
  inline bool has_u2f_counter() const;
  inline void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 1;
  inline ::google::protobuf::uint32 u2f_counter() const;
  inline void set_u2f_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.management.SetU2FCounter)
 private:
  inline void set_has_u2f_counter();
  inline void clear_has_u2f_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 u2f_counter_;
  friend void  protobuf_AddDesc_messages_2dmanagement_2eproto();
  friend void protobuf_AssignDesc_messages_2dmanagement_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmanagement_2eproto();

  void InitAsDefaultInstance();
  static SetU2FCounter* default_instance_;
};
// ===================================================================


// ===================================================================

// Initialize

// optional bytes state = 1;
inline bool Initialize::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Initialize::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Initialize::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Initialize::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Initialize::state() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Initialize.state)
  return *state_;
}
inline void Initialize::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Initialize.state)
}
inline void Initialize::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Initialize.state)
}
inline void Initialize::set_state(const void* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Initialize.state)
}
inline ::std::string* Initialize::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Initialize.state)
  return state_;
}
inline ::std::string* Initialize::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Initialize::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Initialize.state)
}

// optional bool skip_passphrase = 2;
inline bool Initialize::has_skip_passphrase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Initialize::set_has_skip_passphrase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Initialize::clear_has_skip_passphrase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Initialize::clear_skip_passphrase() {
  skip_passphrase_ = false;
  clear_has_skip_passphrase();
}
inline bool Initialize::skip_passphrase() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Initialize.skip_passphrase)
  return skip_passphrase_;
}
inline void Initialize::set_skip_passphrase(bool value) {
  set_has_skip_passphrase();
  skip_passphrase_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Initialize.skip_passphrase)
}

// -------------------------------------------------------------------

// GetFeatures

// -------------------------------------------------------------------

// Features

// optional string vendor = 1;
inline bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Features::vendor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.vendor)
  return *vendor_;
}
inline void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.vendor)
}
inline void Features::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.vendor)
}
inline void Features::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.vendor)
}
inline ::std::string* Features::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.vendor)
  return vendor_;
}
inline ::std::string* Features::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.vendor)
}

// optional uint32 major_version = 2;
inline bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
inline ::google::protobuf::uint32 Features::major_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.major_version)
  return major_version_;
}
inline void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.major_version)
}

// optional uint32 minor_version = 3;
inline bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 Features::minor_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.minor_version)
  return minor_version_;
}
inline void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.minor_version)
}

// optional uint32 patch_version = 4;
inline bool Features::has_patch_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_patch_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_patch_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_patch_version() {
  patch_version_ = 0u;
  clear_has_patch_version();
}
inline ::google::protobuf::uint32 Features::patch_version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.patch_version)
  return patch_version_;
}
inline void Features::set_patch_version(::google::protobuf::uint32 value) {
  set_has_patch_version();
  patch_version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.patch_version)
}

// optional bool bootloader_mode = 5;
inline bool Features::has_bootloader_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_bootloader_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_bootloader_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_bootloader_mode() {
  bootloader_mode_ = false;
  clear_has_bootloader_mode();
}
inline bool Features::bootloader_mode() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.bootloader_mode)
  return bootloader_mode_;
}
inline void Features::set_bootloader_mode(bool value) {
  set_has_bootloader_mode();
  bootloader_mode_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.bootloader_mode)
}

// optional string device_id = 6;
inline bool Features::has_device_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Features::set_has_device_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Features::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Features::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& Features::device_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.device_id)
  return *device_id_;
}
inline void Features::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.device_id)
}
inline void Features::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.device_id)
}
inline void Features::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.device_id)
}
inline ::std::string* Features::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.device_id)
  return device_id_;
}
inline ::std::string* Features::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.device_id)
}

// optional bool pin_protection = 7;
inline bool Features::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Features::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Features::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Features::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Features::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.pin_protection)
  return pin_protection_;
}
inline void Features::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.pin_protection)
}

// optional bool passphrase_protection = 8;
inline bool Features::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Features::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Features::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Features::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Features::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.passphrase_protection)
  return passphrase_protection_;
}
inline void Features::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.passphrase_protection)
}

// optional string language = 9;
inline bool Features::has_language() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Features::set_has_language() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Features::clear_has_language() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Features::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& Features::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.language)
  return *language_;
}
inline void Features::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.language)
}
inline void Features::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.language)
}
inline void Features::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.language)
}
inline ::std::string* Features::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.language)
  return language_;
}
inline ::std::string* Features::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.language)
}

// optional string label = 10;
inline bool Features::has_label() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Features::set_has_label() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Features::clear_has_label() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Features::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Features::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.label)
  return *label_;
}
inline void Features::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.label)
}
inline void Features::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.label)
}
inline void Features::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.label)
}
inline ::std::string* Features::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.label)
  return label_;
}
inline ::std::string* Features::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.label)
}

// optional bool initialized = 12;
inline bool Features::has_initialized() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Features::set_has_initialized() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Features::clear_has_initialized() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Features::clear_initialized() {
  initialized_ = false;
  clear_has_initialized();
}
inline bool Features::initialized() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.initialized)
  return initialized_;
}
inline void Features::set_initialized(bool value) {
  set_has_initialized();
  initialized_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.initialized)
}

// optional bytes revision = 13;
inline bool Features::has_revision() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Features::set_has_revision() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Features::clear_has_revision() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Features::clear_revision() {
  if (revision_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& Features::revision() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.revision)
  return *revision_;
}
inline void Features::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.revision)
}
inline void Features::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.revision)
}
inline void Features::set_revision(const void* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.revision)
}
inline ::std::string* Features::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.revision)
  return revision_;
}
inline ::std::string* Features::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.revision)
}

// optional bytes bootloader_hash = 14;
inline bool Features::has_bootloader_hash() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Features::set_has_bootloader_hash() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Features::clear_has_bootloader_hash() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Features::clear_bootloader_hash() {
  if (bootloader_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bootloader_hash_->clear();
  }
  clear_has_bootloader_hash();
}
inline const ::std::string& Features::bootloader_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.bootloader_hash)
  return *bootloader_hash_;
}
inline void Features::set_bootloader_hash(const ::std::string& value) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.bootloader_hash)
}
inline void Features::set_bootloader_hash(const char* value) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.bootloader_hash)
}
inline void Features::set_bootloader_hash(const void* value, size_t size) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.bootloader_hash)
}
inline ::std::string* Features::mutable_bootloader_hash() {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bootloader_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.bootloader_hash)
  return bootloader_hash_;
}
inline ::std::string* Features::release_bootloader_hash() {
  clear_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bootloader_hash_;
    bootloader_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_bootloader_hash(::std::string* bootloader_hash) {
  if (bootloader_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bootloader_hash_;
  }
  if (bootloader_hash) {
    set_has_bootloader_hash();
    bootloader_hash_ = bootloader_hash;
  } else {
    clear_has_bootloader_hash();
    bootloader_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.bootloader_hash)
}

// optional bool imported = 15;
inline bool Features::has_imported() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Features::set_has_imported() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Features::clear_has_imported() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Features::clear_imported() {
  imported_ = false;
  clear_has_imported();
}
inline bool Features::imported() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.imported)
  return imported_;
}
inline void Features::set_imported(bool value) {
  set_has_imported();
  imported_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.imported)
}

// optional bool pin_cached = 16;
inline bool Features::has_pin_cached() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Features::set_has_pin_cached() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Features::clear_has_pin_cached() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Features::clear_pin_cached() {
  pin_cached_ = false;
  clear_has_pin_cached();
}
inline bool Features::pin_cached() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.pin_cached)
  return pin_cached_;
}
inline void Features::set_pin_cached(bool value) {
  set_has_pin_cached();
  pin_cached_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.pin_cached)
}

// optional bool passphrase_cached = 17;
inline bool Features::has_passphrase_cached() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Features::set_has_passphrase_cached() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Features::clear_has_passphrase_cached() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Features::clear_passphrase_cached() {
  passphrase_cached_ = false;
  clear_has_passphrase_cached();
}
inline bool Features::passphrase_cached() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.passphrase_cached)
  return passphrase_cached_;
}
inline void Features::set_passphrase_cached(bool value) {
  set_has_passphrase_cached();
  passphrase_cached_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.passphrase_cached)
}

// optional bool firmware_present = 18;
inline bool Features::has_firmware_present() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Features::set_has_firmware_present() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Features::clear_has_firmware_present() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Features::clear_firmware_present() {
  firmware_present_ = false;
  clear_has_firmware_present();
}
inline bool Features::firmware_present() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.firmware_present)
  return firmware_present_;
}
inline void Features::set_firmware_present(bool value) {
  set_has_firmware_present();
  firmware_present_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.firmware_present)
}

// optional bool needs_backup = 19;
inline bool Features::has_needs_backup() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Features::set_has_needs_backup() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Features::clear_has_needs_backup() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Features::clear_needs_backup() {
  needs_backup_ = false;
  clear_has_needs_backup();
}
inline bool Features::needs_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.needs_backup)
  return needs_backup_;
}
inline void Features::set_needs_backup(bool value) {
  set_has_needs_backup();
  needs_backup_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.needs_backup)
}

// optional uint32 flags = 20;
inline bool Features::has_flags() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Features::set_has_flags() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Features::clear_has_flags() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Features::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Features::flags() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.flags)
  return flags_;
}
inline void Features::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.flags)
}

// optional string model = 21;
inline bool Features::has_model() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Features::set_has_model() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Features::clear_has_model() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Features::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Features::model() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.model)
  return *model_;
}
inline void Features::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.model)
}
inline void Features::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.model)
}
inline void Features::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.model)
}
inline ::std::string* Features::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.model)
  return model_;
}
inline ::std::string* Features::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.model)
}

// optional uint32 fw_major = 22;
inline bool Features::has_fw_major() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Features::set_has_fw_major() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Features::clear_has_fw_major() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Features::clear_fw_major() {
  fw_major_ = 0u;
  clear_has_fw_major();
}
inline ::google::protobuf::uint32 Features::fw_major() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_major)
  return fw_major_;
}
inline void Features::set_fw_major(::google::protobuf::uint32 value) {
  set_has_fw_major();
  fw_major_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_major)
}

// optional uint32 fw_minor = 23;
inline bool Features::has_fw_minor() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Features::set_has_fw_minor() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Features::clear_has_fw_minor() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Features::clear_fw_minor() {
  fw_minor_ = 0u;
  clear_has_fw_minor();
}
inline ::google::protobuf::uint32 Features::fw_minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_minor)
  return fw_minor_;
}
inline void Features::set_fw_minor(::google::protobuf::uint32 value) {
  set_has_fw_minor();
  fw_minor_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_minor)
}

// optional uint32 fw_patch = 24;
inline bool Features::has_fw_patch() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Features::set_has_fw_patch() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Features::clear_has_fw_patch() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Features::clear_fw_patch() {
  fw_patch_ = 0u;
  clear_has_fw_patch();
}
inline ::google::protobuf::uint32 Features::fw_patch() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_patch)
  return fw_patch_;
}
inline void Features::set_fw_patch(::google::protobuf::uint32 value) {
  set_has_fw_patch();
  fw_patch_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_patch)
}

// optional string fw_vendor = 25;
inline bool Features::has_fw_vendor() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Features::set_has_fw_vendor() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Features::clear_has_fw_vendor() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Features::clear_fw_vendor() {
  if (fw_vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_->clear();
  }
  clear_has_fw_vendor();
}
inline const ::std::string& Features::fw_vendor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_vendor)
  return *fw_vendor_;
}
inline void Features::set_fw_vendor(const ::std::string& value) {
  set_has_fw_vendor();
  if (fw_vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_ = new ::std::string;
  }
  fw_vendor_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_vendor)
}
inline void Features::set_fw_vendor(const char* value) {
  set_has_fw_vendor();
  if (fw_vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_ = new ::std::string;
  }
  fw_vendor_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.fw_vendor)
}
inline void Features::set_fw_vendor(const char* value, size_t size) {
  set_has_fw_vendor();
  if (fw_vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_ = new ::std::string;
  }
  fw_vendor_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.fw_vendor)
}
inline ::std::string* Features::mutable_fw_vendor() {
  set_has_fw_vendor();
  if (fw_vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.fw_vendor)
  return fw_vendor_;
}
inline ::std::string* Features::release_fw_vendor() {
  clear_has_fw_vendor();
  if (fw_vendor_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fw_vendor_;
    fw_vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_fw_vendor(::std::string* fw_vendor) {
  if (fw_vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fw_vendor_;
  }
  if (fw_vendor) {
    set_has_fw_vendor();
    fw_vendor_ = fw_vendor;
  } else {
    clear_has_fw_vendor();
    fw_vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.fw_vendor)
}

// optional bytes fw_vendor_keys = 26;
inline bool Features::has_fw_vendor_keys() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Features::set_has_fw_vendor_keys() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Features::clear_has_fw_vendor_keys() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Features::clear_fw_vendor_keys() {
  if (fw_vendor_keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_keys_->clear();
  }
  clear_has_fw_vendor_keys();
}
inline const ::std::string& Features::fw_vendor_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.fw_vendor_keys)
  return *fw_vendor_keys_;
}
inline void Features::set_fw_vendor_keys(const ::std::string& value) {
  set_has_fw_vendor_keys();
  if (fw_vendor_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_keys_ = new ::std::string;
  }
  fw_vendor_keys_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.fw_vendor_keys)
}
inline void Features::set_fw_vendor_keys(const char* value) {
  set_has_fw_vendor_keys();
  if (fw_vendor_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_keys_ = new ::std::string;
  }
  fw_vendor_keys_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Features.fw_vendor_keys)
}
inline void Features::set_fw_vendor_keys(const void* value, size_t size) {
  set_has_fw_vendor_keys();
  if (fw_vendor_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_keys_ = new ::std::string;
  }
  fw_vendor_keys_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Features.fw_vendor_keys)
}
inline ::std::string* Features::mutable_fw_vendor_keys() {
  set_has_fw_vendor_keys();
  if (fw_vendor_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fw_vendor_keys_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Features.fw_vendor_keys)
  return fw_vendor_keys_;
}
inline ::std::string* Features::release_fw_vendor_keys() {
  clear_has_fw_vendor_keys();
  if (fw_vendor_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fw_vendor_keys_;
    fw_vendor_keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Features::set_allocated_fw_vendor_keys(::std::string* fw_vendor_keys) {
  if (fw_vendor_keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fw_vendor_keys_;
  }
  if (fw_vendor_keys) {
    set_has_fw_vendor_keys();
    fw_vendor_keys_ = fw_vendor_keys;
  } else {
    clear_has_fw_vendor_keys();
    fw_vendor_keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Features.fw_vendor_keys)
}

// optional bool unfinished_backup = 27;
inline bool Features::has_unfinished_backup() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Features::set_has_unfinished_backup() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Features::clear_has_unfinished_backup() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Features::clear_unfinished_backup() {
  unfinished_backup_ = false;
  clear_has_unfinished_backup();
}
inline bool Features::unfinished_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Features.unfinished_backup)
  return unfinished_backup_;
}
inline void Features::set_unfinished_backup(bool value) {
  set_has_unfinished_backup();
  unfinished_backup_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Features.unfinished_backup)
}

// -------------------------------------------------------------------

// ClearSession

// -------------------------------------------------------------------

// ApplySettings

// optional string language = 1;
inline bool ApplySettings::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplySettings::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplySettings::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplySettings::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& ApplySettings::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.language)
  return *language_;
}
inline void ApplySettings::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.language)
}
inline void ApplySettings::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.ApplySettings.language)
}
inline void ApplySettings::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.ApplySettings.language)
}
inline ::std::string* ApplySettings::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.language)
  return language_;
}
inline ::std::string* ApplySettings::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApplySettings::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.language)
}

// optional string label = 2;
inline bool ApplySettings::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplySettings::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplySettings::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplySettings::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ApplySettings::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.label)
  return *label_;
}
inline void ApplySettings::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.label)
}
inline void ApplySettings::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.ApplySettings.label)
}
inline void ApplySettings::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.ApplySettings.label)
}
inline ::std::string* ApplySettings::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.label)
  return label_;
}
inline ::std::string* ApplySettings::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApplySettings::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.label)
}

// optional bool use_passphrase = 3;
inline bool ApplySettings::has_use_passphrase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplySettings::set_has_use_passphrase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplySettings::clear_has_use_passphrase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplySettings::clear_use_passphrase() {
  use_passphrase_ = false;
  clear_has_use_passphrase();
}
inline bool ApplySettings::use_passphrase() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.use_passphrase)
  return use_passphrase_;
}
inline void ApplySettings::set_use_passphrase(bool value) {
  set_has_use_passphrase();
  use_passphrase_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.use_passphrase)
}

// optional bytes homescreen = 4;
inline bool ApplySettings::has_homescreen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplySettings::set_has_homescreen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplySettings::clear_has_homescreen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplySettings::clear_homescreen() {
  if (homescreen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homescreen_->clear();
  }
  clear_has_homescreen();
}
inline const ::std::string& ApplySettings::homescreen() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.homescreen)
  return *homescreen_;
}
inline void ApplySettings::set_homescreen(const ::std::string& value) {
  set_has_homescreen();
  if (homescreen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homescreen_ = new ::std::string;
  }
  homescreen_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.homescreen)
}
inline void ApplySettings::set_homescreen(const char* value) {
  set_has_homescreen();
  if (homescreen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homescreen_ = new ::std::string;
  }
  homescreen_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.ApplySettings.homescreen)
}
inline void ApplySettings::set_homescreen(const void* value, size_t size) {
  set_has_homescreen();
  if (homescreen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homescreen_ = new ::std::string;
  }
  homescreen_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.ApplySettings.homescreen)
}
inline ::std::string* ApplySettings::mutable_homescreen() {
  set_has_homescreen();
  if (homescreen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    homescreen_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ApplySettings.homescreen)
  return homescreen_;
}
inline ::std::string* ApplySettings::release_homescreen() {
  clear_has_homescreen();
  if (homescreen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = homescreen_;
    homescreen_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ApplySettings::set_allocated_homescreen(::std::string* homescreen) {
  if (homescreen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete homescreen_;
  }
  if (homescreen) {
    set_has_homescreen();
    homescreen_ = homescreen;
  } else {
    clear_has_homescreen();
    homescreen_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ApplySettings.homescreen)
}

// optional .hw.trezor.messages.management.ApplySettings.PassphraseSourceType passphrase_source = 5;
inline bool ApplySettings::has_passphrase_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplySettings::set_has_passphrase_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplySettings::clear_has_passphrase_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplySettings::clear_passphrase_source() {
  passphrase_source_ = 0;
  clear_has_passphrase_source();
}
inline ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType ApplySettings::passphrase_source() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.passphrase_source)
  return static_cast< ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType >(passphrase_source_);
}
inline void ApplySettings::set_passphrase_source(::hw::trezor::messages::management::ApplySettings_PassphraseSourceType value) {
  assert(::hw::trezor::messages::management::ApplySettings_PassphraseSourceType_IsValid(value));
  set_has_passphrase_source();
  passphrase_source_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.passphrase_source)
}

// optional uint32 auto_lock_delay_ms = 6;
inline bool ApplySettings::has_auto_lock_delay_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplySettings::set_has_auto_lock_delay_ms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplySettings::clear_has_auto_lock_delay_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplySettings::clear_auto_lock_delay_ms() {
  auto_lock_delay_ms_ = 0u;
  clear_has_auto_lock_delay_ms();
}
inline ::google::protobuf::uint32 ApplySettings::auto_lock_delay_ms() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplySettings.auto_lock_delay_ms)
  return auto_lock_delay_ms_;
}
inline void ApplySettings::set_auto_lock_delay_ms(::google::protobuf::uint32 value) {
  set_has_auto_lock_delay_ms();
  auto_lock_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplySettings.auto_lock_delay_ms)
}

// -------------------------------------------------------------------

// ApplyFlags

// optional uint32 flags = 1;
inline bool ApplyFlags::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyFlags::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyFlags::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyFlags::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 ApplyFlags::flags() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ApplyFlags.flags)
  return flags_;
}
inline void ApplyFlags::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ApplyFlags.flags)
}

// -------------------------------------------------------------------

// ChangePin

// optional bool remove = 1;
inline bool ChangePin::has_remove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePin::set_has_remove() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePin::clear_has_remove() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePin::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
inline bool ChangePin::remove() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ChangePin.remove)
  return remove_;
}
inline void ChangePin::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ChangePin.remove)
}

// -------------------------------------------------------------------

// Ping

// optional string message = 1;
inline bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Ping::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.message)
  return *message_;
}
inline void Ping::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.message)
}
inline void Ping::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Ping.message)
}
inline void Ping::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Ping.message)
}
inline ::std::string* Ping::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Ping.message)
  return message_;
}
inline ::std::string* Ping::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Ping::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Ping.message)
}

// optional bool button_protection = 2;
inline bool Ping::has_button_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_button_protection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_button_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_button_protection() {
  button_protection_ = false;
  clear_has_button_protection();
}
inline bool Ping::button_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.button_protection)
  return button_protection_;
}
inline void Ping::set_button_protection(bool value) {
  set_has_button_protection();
  button_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.button_protection)
}

// optional bool pin_protection = 3;
inline bool Ping::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ping::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ping::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Ping::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.pin_protection)
  return pin_protection_;
}
inline void Ping::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.pin_protection)
}

// optional bool passphrase_protection = 4;
inline bool Ping::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ping::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ping::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Ping::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Ping.passphrase_protection)
  return passphrase_protection_;
}
inline void Ping::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Ping.passphrase_protection)
}

// -------------------------------------------------------------------

// Cancel

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 GetEntropy::size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.GetEntropy.size)
  return size_;
}
inline void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.GetEntropy.size)
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entropy::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& Entropy::entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.Entropy.entropy)
  return *entropy_;
}
inline void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.Entropy.entropy)
}
inline void Entropy::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.Entropy.entropy)
}
inline void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.Entropy.entropy)
}
inline ::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.Entropy.entropy)
  return entropy_;
}
inline ::std::string* Entropy::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Entropy::set_allocated_entropy(::std::string* entropy) {
  if (entropy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entropy_;
  }
  if (entropy) {
    set_has_entropy();
    entropy_ = entropy;
  } else {
    clear_has_entropy();
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.Entropy.entropy)
}

// -------------------------------------------------------------------

// WipeDevice

// -------------------------------------------------------------------

// LoadDevice

// optional string mnemonic = 1;
inline bool LoadDevice::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadDevice::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadDevice::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadDevice::clear_mnemonic() {
  if (mnemonic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mnemonic_->clear();
  }
  clear_has_mnemonic();
}
inline const ::std::string& LoadDevice::mnemonic() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.mnemonic)
  return *mnemonic_;
}
inline void LoadDevice::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.mnemonic)
}
inline void LoadDevice::set_mnemonic(const char* value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.LoadDevice.mnemonic)
}
inline void LoadDevice::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.LoadDevice.mnemonic)
}
inline ::std::string* LoadDevice::mutable_mnemonic() {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mnemonic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.mnemonic)
  return mnemonic_;
}
inline ::std::string* LoadDevice::release_mnemonic() {
  clear_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mnemonic_;
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoadDevice::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mnemonic_;
  }
  if (mnemonic) {
    set_has_mnemonic();
    mnemonic_ = mnemonic;
  } else {
    clear_has_mnemonic();
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.mnemonic)
}

// optional .hw.trezor.messages.common.HDNodeType node = 2;
inline bool LoadDevice::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadDevice::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadDevice::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadDevice::clear_node() {
  if (node_ != NULL) node_->::hw::trezor::messages::common::HDNodeType::Clear();
  clear_has_node();
}
inline const ::hw::trezor::messages::common::HDNodeType& LoadDevice::node() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::hw::trezor::messages::common::HDNodeType* LoadDevice::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::hw::trezor::messages::common::HDNodeType;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.node)
  return node_;
}
inline ::hw::trezor::messages::common::HDNodeType* LoadDevice::release_node() {
  clear_has_node();
  ::hw::trezor::messages::common::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void LoadDevice::set_allocated_node(::hw::trezor::messages::common::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.node)
}

// optional string pin = 3;
inline bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadDevice::clear_pin() {
  if (pin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& LoadDevice::pin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.pin)
  return *pin_;
}
inline void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.pin)
}
inline void LoadDevice::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.LoadDevice.pin)
}
inline void LoadDevice::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.LoadDevice.pin)
}
inline ::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.pin)
  return pin_;
}
inline ::std::string* LoadDevice::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoadDevice::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.pin)
}

// optional bool passphrase_protection = 4;
inline bool LoadDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool LoadDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void LoadDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.passphrase_protection)
}

// optional string language = 5 [default = "english"];
inline bool LoadDevice::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadDevice::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& LoadDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.language)
  return *language_;
}
inline void LoadDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.language)
}
inline void LoadDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.LoadDevice.language)
}
inline void LoadDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.LoadDevice.language)
}
inline ::std::string* LoadDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.language)
  return language_;
}
inline ::std::string* LoadDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void LoadDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.language)
}

// optional string label = 6;
inline bool LoadDevice::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoadDevice::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoadDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoadDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& LoadDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.label)
  return *label_;
}
inline void LoadDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.label)
}
inline void LoadDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.LoadDevice.label)
}
inline void LoadDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.LoadDevice.label)
}
inline ::std::string* LoadDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.LoadDevice.label)
  return label_;
}
inline ::std::string* LoadDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoadDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.LoadDevice.label)
}

// optional bool skip_checksum = 7;
inline bool LoadDevice::has_skip_checksum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoadDevice::set_has_skip_checksum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoadDevice::clear_has_skip_checksum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoadDevice::clear_skip_checksum() {
  skip_checksum_ = false;
  clear_has_skip_checksum();
}
inline bool LoadDevice::skip_checksum() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.skip_checksum)
  return skip_checksum_;
}
inline void LoadDevice::set_skip_checksum(bool value) {
  set_has_skip_checksum();
  skip_checksum_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.skip_checksum)
}

// optional uint32 u2f_counter = 8;
inline bool LoadDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoadDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoadDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoadDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 LoadDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.LoadDevice.u2f_counter)
  return u2f_counter_;
}
inline void LoadDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.LoadDevice.u2f_counter)
}

// -------------------------------------------------------------------

// ResetDevice

// optional bool display_random = 1;
inline bool ResetDevice::has_display_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetDevice::set_has_display_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetDevice::clear_has_display_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetDevice::clear_display_random() {
  display_random_ = false;
  clear_has_display_random();
}
inline bool ResetDevice::display_random() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.display_random)
  return display_random_;
}
inline void ResetDevice::set_display_random(bool value) {
  set_has_display_random();
  display_random_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.display_random)
}

// optional uint32 strength = 2 [default = 256];
inline bool ResetDevice::has_strength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetDevice::set_has_strength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetDevice::clear_has_strength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetDevice::clear_strength() {
  strength_ = 256u;
  clear_has_strength();
}
inline ::google::protobuf::uint32 ResetDevice::strength() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.strength)
  return strength_;
}
inline void ResetDevice::set_strength(::google::protobuf::uint32 value) {
  set_has_strength();
  strength_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.strength)
}

// optional bool passphrase_protection = 3;
inline bool ResetDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool ResetDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void ResetDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.passphrase_protection)
}

// optional bool pin_protection = 4;
inline bool ResetDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResetDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResetDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResetDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool ResetDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.pin_protection)
  return pin_protection_;
}
inline void ResetDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.pin_protection)
}

// optional string language = 5 [default = "english"];
inline bool ResetDevice::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResetDevice::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResetDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResetDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& ResetDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.language)
  return *language_;
}
inline void ResetDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.language)
}
inline void ResetDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.ResetDevice.language)
}
inline void ResetDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.ResetDevice.language)
}
inline ::std::string* ResetDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ResetDevice.language)
  return language_;
}
inline ::std::string* ResetDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void ResetDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ResetDevice.language)
}

// optional string label = 6;
inline bool ResetDevice::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResetDevice::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResetDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResetDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ResetDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.label)
  return *label_;
}
inline void ResetDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.label)
}
inline void ResetDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.ResetDevice.label)
}
inline void ResetDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.ResetDevice.label)
}
inline ::std::string* ResetDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.ResetDevice.label)
  return label_;
}
inline ::std::string* ResetDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResetDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.ResetDevice.label)
}

// optional uint32 u2f_counter = 7;
inline bool ResetDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResetDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResetDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResetDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 ResetDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.u2f_counter)
  return u2f_counter_;
}
inline void ResetDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.u2f_counter)
}

// optional bool skip_backup = 8;
inline bool ResetDevice::has_skip_backup() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResetDevice::set_has_skip_backup() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResetDevice::clear_has_skip_backup() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResetDevice::clear_skip_backup() {
  skip_backup_ = false;
  clear_has_skip_backup();
}
inline bool ResetDevice::skip_backup() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.ResetDevice.skip_backup)
  return skip_backup_;
}
inline void ResetDevice::set_skip_backup(bool value) {
  set_has_skip_backup();
  skip_backup_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.ResetDevice.skip_backup)
}

// -------------------------------------------------------------------

// BackupDevice

// -------------------------------------------------------------------

// EntropyRequest

// -------------------------------------------------------------------

// EntropyAck

// optional bytes entropy = 1;
inline bool EntropyAck::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntropyAck::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntropyAck::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntropyAck::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& EntropyAck::entropy() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.EntropyAck.entropy)
  return *entropy_;
}
inline void EntropyAck::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.EntropyAck.entropy)
}
inline void EntropyAck::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.EntropyAck.entropy)
}
inline void EntropyAck::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.EntropyAck.entropy)
}
inline ::std::string* EntropyAck::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    entropy_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.EntropyAck.entropy)
  return entropy_;
}
inline ::std::string* EntropyAck::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntropyAck::set_allocated_entropy(::std::string* entropy) {
  if (entropy_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete entropy_;
  }
  if (entropy) {
    set_has_entropy();
    entropy_ = entropy;
  } else {
    clear_has_entropy();
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.EntropyAck.entropy)
}

// -------------------------------------------------------------------

// RecoveryDevice

// optional uint32 word_count = 1;
inline bool RecoveryDevice::has_word_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecoveryDevice::set_has_word_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecoveryDevice::clear_has_word_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecoveryDevice::clear_word_count() {
  word_count_ = 0u;
  clear_has_word_count();
}
inline ::google::protobuf::uint32 RecoveryDevice::word_count() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.word_count)
  return word_count_;
}
inline void RecoveryDevice::set_word_count(::google::protobuf::uint32 value) {
  set_has_word_count();
  word_count_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.word_count)
}

// optional bool passphrase_protection = 2;
inline bool RecoveryDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecoveryDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecoveryDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecoveryDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool RecoveryDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void RecoveryDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.passphrase_protection)
}

// optional bool pin_protection = 3;
inline bool RecoveryDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecoveryDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecoveryDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecoveryDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool RecoveryDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.pin_protection)
  return pin_protection_;
}
inline void RecoveryDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.pin_protection)
}

// optional string language = 4 [default = "english"];
inline bool RecoveryDevice::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecoveryDevice::set_has_language() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecoveryDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecoveryDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& RecoveryDevice::language() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.language)
  return *language_;
}
inline void RecoveryDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.language)
}
inline void RecoveryDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.RecoveryDevice.language)
}
inline void RecoveryDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.RecoveryDevice.language)
}
inline ::std::string* RecoveryDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.RecoveryDevice.language)
  return language_;
}
inline ::std::string* RecoveryDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void RecoveryDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.RecoveryDevice.language)
}

// optional string label = 5;
inline bool RecoveryDevice::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecoveryDevice::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecoveryDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecoveryDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& RecoveryDevice::label() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.label)
  return *label_;
}
inline void RecoveryDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.label)
}
inline void RecoveryDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.RecoveryDevice.label)
}
inline void RecoveryDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.RecoveryDevice.label)
}
inline ::std::string* RecoveryDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.RecoveryDevice.label)
  return label_;
}
inline ::std::string* RecoveryDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RecoveryDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.RecoveryDevice.label)
}

// optional bool enforce_wordlist = 6;
inline bool RecoveryDevice::has_enforce_wordlist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecoveryDevice::set_has_enforce_wordlist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecoveryDevice::clear_has_enforce_wordlist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecoveryDevice::clear_enforce_wordlist() {
  enforce_wordlist_ = false;
  clear_has_enforce_wordlist();
}
inline bool RecoveryDevice::enforce_wordlist() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.enforce_wordlist)
  return enforce_wordlist_;
}
inline void RecoveryDevice::set_enforce_wordlist(bool value) {
  set_has_enforce_wordlist();
  enforce_wordlist_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.enforce_wordlist)
}

// optional .hw.trezor.messages.management.RecoveryDevice.RecoveryDeviceType type = 8;
inline bool RecoveryDevice::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecoveryDevice::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecoveryDevice::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecoveryDevice::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType RecoveryDevice::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.type)
  return static_cast< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType >(type_);
}
inline void RecoveryDevice::set_type(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType value) {
  assert(::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.type)
}

// optional uint32 u2f_counter = 9;
inline bool RecoveryDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecoveryDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecoveryDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecoveryDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 RecoveryDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.u2f_counter)
  return u2f_counter_;
}
inline void RecoveryDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.u2f_counter)
}

// optional bool dry_run = 10;
inline bool RecoveryDevice::has_dry_run() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RecoveryDevice::set_has_dry_run() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RecoveryDevice::clear_has_dry_run() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RecoveryDevice::clear_dry_run() {
  dry_run_ = false;
  clear_has_dry_run();
}
inline bool RecoveryDevice::dry_run() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.RecoveryDevice.dry_run)
  return dry_run_;
}
inline void RecoveryDevice::set_dry_run(bool value) {
  set_has_dry_run();
  dry_run_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.RecoveryDevice.dry_run)
}

// -------------------------------------------------------------------

// WordRequest

// optional .hw.trezor.messages.management.WordRequest.WordRequestType type = 1;
inline bool WordRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hw::trezor::messages::management::WordRequest_WordRequestType WordRequest::type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.WordRequest.type)
  return static_cast< ::hw::trezor::messages::management::WordRequest_WordRequestType >(type_);
}
inline void WordRequest::set_type(::hw::trezor::messages::management::WordRequest_WordRequestType value) {
  assert(::hw::trezor::messages::management::WordRequest_WordRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.WordRequest.type)
}

// -------------------------------------------------------------------

// WordAck

// required string word = 1;
inline bool WordAck::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordAck::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordAck::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordAck::clear_word() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& WordAck::word() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.WordAck.word)
  return *word_;
}
inline void WordAck::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.WordAck.word)
}
inline void WordAck::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.management.WordAck.word)
}
inline void WordAck::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.management.WordAck.word)
}
inline ::std::string* WordAck::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.management.WordAck.word)
  return word_;
}
inline ::std::string* WordAck::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WordAck::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.management.WordAck.word)
}

// -------------------------------------------------------------------

// SetU2FCounter

// optional uint32 u2f_counter = 1;
inline bool SetU2FCounter::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetU2FCounter::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetU2FCounter::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetU2FCounter::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 SetU2FCounter::u2f_counter() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.management.SetU2FCounter.u2f_counter)
  return u2f_counter_;
}
inline void SetU2FCounter::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.management.SetU2FCounter.u2f_counter)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace management
}  // namespace messages
}  // namespace trezor
}  // namespace hw

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType>() {
  return ::hw::trezor::messages::management::ApplySettings_PassphraseSourceType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType>() {
  return ::hw::trezor::messages::management::RecoveryDevice_RecoveryDeviceType_descriptor();
}
template <> struct is_proto_enum< ::hw::trezor::messages::management::WordRequest_WordRequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hw::trezor::messages::management::WordRequest_WordRequestType>() {
  return ::hw::trezor::messages::management::WordRequest_WordRequestType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2dmanagement_2eproto__INCLUDED
