// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-monero.proto

#ifndef PROTOBUF_messages_2dmonero_2eproto__INCLUDED
#define PROTOBUF_messages_2dmonero_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace hw {
namespace trezor {
namespace messages {
namespace monero {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2dmonero_2eproto();
void protobuf_AssignDesc_messages_2dmonero_2eproto();
void protobuf_ShutdownFile_messages_2dmonero_2eproto();

class MoneroGetAddress;
class MoneroAddress;
class MoneroGetWatchKey;
class MoneroWatchKey;
class MoneroTransactionDestinationEntry;
class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress;
class MoneroTransactionInitRequest;
class MoneroTransactionInitRequest_MoneroTransactionData;
class MoneroTransactionInitAck;
class MoneroTransactionSourceEntry;
class MoneroTransactionSourceEntry_MoneroRctKey;
class MoneroTransactionSourceEntry_MoneroOutputEntry;
class MoneroTransactionSourceEntry_MoneroMultisigKLRki;
class MoneroTransactionSetInputRequest;
class MoneroTransactionSetInputAck;
class MoneroTransactionInputsPermutationRequest;
class MoneroTransactionInputsPermutationAck;
class MoneroTransactionInputViniRequest;
class MoneroTransactionInputViniAck;
class MoneroTransactionSetOutputRequest;
class MoneroTransactionSetOutputAck;
class MoneroTransactionAllOutSetRequest;
class MoneroTransactionAllOutSetAck;
class MoneroTransactionAllOutSetAck_MoneroRingCtSig;
class MoneroTransactionMlsagDoneRequest;
class MoneroTransactionMlsagDoneAck;
class MoneroTransactionSignInputRequest;
class MoneroTransactionSignInputAck;
class MoneroTransactionFinalRequest;
class MoneroTransactionFinalAck;
class MoneroTransactionSignRequest;
class MoneroKeyImageExportInitRequest;
class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList;
class MoneroKeyImageExportInitAck;
class MoneroKeyImageSyncStepRequest;
class MoneroKeyImageSyncStepRequest_MoneroTransferDetails;
class MoneroKeyImageSyncStepAck;
class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage;
class MoneroKeyImageSyncFinalRequest;
class MoneroKeyImageSyncFinalAck;
class MoneroKeyImageSyncRequest;
class DebugMoneroDiagRequest;
class DebugMoneroDiagAck;

// ===================================================================

class MoneroGetAddress : public ::google::protobuf::Message {
 public:
  MoneroGetAddress();
  virtual ~MoneroGetAddress();

  MoneroGetAddress(const MoneroGetAddress& from);

  inline MoneroGetAddress& operator=(const MoneroGetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroGetAddress& default_instance();

  void Swap(MoneroGetAddress* other);

  // implements Message ----------------------------------------------

  MoneroGetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroGetAddress& from);
  void MergeFrom(const MoneroGetAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  inline bool has_show_display() const;
  inline void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  inline bool show_display() const;
  inline void set_show_display(bool value);

  // optional uint32 network_type = 3;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 network_type() const;
  inline void set_network_type(::google::protobuf::uint32 value);

  // optional uint32 account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline ::google::protobuf::uint32 account() const;
  inline void set_account(::google::protobuf::uint32 value);

  // optional uint32 minor = 5;
  inline bool has_minor() const;
  inline void clear_minor();
  static const int kMinorFieldNumber = 5;
  inline ::google::protobuf::uint32 minor() const;
  inline void set_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetAddress)
 private:
  inline void set_has_show_display();
  inline void clear_has_show_display();
  inline void set_has_network_type();
  inline void clear_has_network_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_minor();
  inline void clear_has_minor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  ::google::protobuf::uint32 network_type_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::uint32 minor_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroGetAddress* default_instance_;
};
// -------------------------------------------------------------------

class MoneroAddress : public ::google::protobuf::Message {
 public:
  MoneroAddress();
  virtual ~MoneroAddress();

  MoneroAddress(const MoneroAddress& from);

  inline MoneroAddress& operator=(const MoneroAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroAddress& default_instance();

  void Swap(MoneroAddress* other);

  // implements Message ----------------------------------------------

  MoneroAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroAddress& from);
  void MergeFrom(const MoneroAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroAddress)
 private:
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroAddress* default_instance_;
};
// -------------------------------------------------------------------

class MoneroGetWatchKey : public ::google::protobuf::Message {
 public:
  MoneroGetWatchKey();
  virtual ~MoneroGetWatchKey();

  MoneroGetWatchKey(const MoneroGetWatchKey& from);

  inline MoneroGetWatchKey& operator=(const MoneroGetWatchKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroGetWatchKey& default_instance();

  void Swap(MoneroGetWatchKey* other);

  // implements Message ----------------------------------------------

  MoneroGetWatchKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroGetWatchKey& from);
  void MergeFrom(const MoneroGetWatchKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network_type = 2;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 network_type() const;
  inline void set_network_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroGetWatchKey)
 private:
  inline void set_has_network_type();
  inline void clear_has_network_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 network_type_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroGetWatchKey* default_instance_;
};
// -------------------------------------------------------------------

class MoneroWatchKey : public ::google::protobuf::Message {
 public:
  MoneroWatchKey();
  virtual ~MoneroWatchKey();

  MoneroWatchKey(const MoneroWatchKey& from);

  inline MoneroWatchKey& operator=(const MoneroWatchKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroWatchKey& default_instance();

  void Swap(MoneroWatchKey* other);

  // implements Message ----------------------------------------------

  MoneroWatchKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroWatchKey& from);
  void MergeFrom(const MoneroWatchKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes watch_key = 1;
  inline bool has_watch_key() const;
  inline void clear_watch_key();
  static const int kWatchKeyFieldNumber = 1;
  inline const ::std::string& watch_key() const;
  inline void set_watch_key(const ::std::string& value);
  inline void set_watch_key(const char* value);
  inline void set_watch_key(const void* value, size_t size);
  inline ::std::string* mutable_watch_key();
  inline ::std::string* release_watch_key();
  inline void set_allocated_watch_key(::std::string* watch_key);

  // optional bytes address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroWatchKey)
 private:
  inline void set_has_watch_key();
  inline void clear_has_watch_key();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* watch_key_;
  ::std::string* address_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroWatchKey* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry_MoneroAccountPublicAddress : public ::google::protobuf::Message {
 public:
  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress();
  virtual ~MoneroTransactionDestinationEntry_MoneroAccountPublicAddress();

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);

  inline MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& operator=(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& default_instance();

  void Swap(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* other);

  // implements Message ----------------------------------------------

  MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  void MergeFrom(const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes spend_public_key = 1;
  inline bool has_spend_public_key() const;
  inline void clear_spend_public_key();
  static const int kSpendPublicKeyFieldNumber = 1;
  inline const ::std::string& spend_public_key() const;
  inline void set_spend_public_key(const ::std::string& value);
  inline void set_spend_public_key(const char* value);
  inline void set_spend_public_key(const void* value, size_t size);
  inline ::std::string* mutable_spend_public_key();
  inline ::std::string* release_spend_public_key();
  inline void set_allocated_spend_public_key(::std::string* spend_public_key);

  // optional bytes view_public_key = 2;
  inline bool has_view_public_key() const;
  inline void clear_view_public_key();
  static const int kViewPublicKeyFieldNumber = 2;
  inline const ::std::string& view_public_key() const;
  inline void set_view_public_key(const ::std::string& value);
  inline void set_view_public_key(const char* value);
  inline void set_view_public_key(const void* value, size_t size);
  inline ::std::string* mutable_view_public_key();
  inline ::std::string* release_view_public_key();
  inline void set_allocated_view_public_key(::std::string* view_public_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress)
 private:
  inline void set_has_spend_public_key();
  inline void clear_has_spend_public_key();
  inline void set_has_view_public_key();
  inline void clear_has_view_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* spend_public_key_;
  ::std::string* view_public_key_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionDestinationEntry : public ::google::protobuf::Message {
 public:
  MoneroTransactionDestinationEntry();
  virtual ~MoneroTransactionDestinationEntry();

  MoneroTransactionDestinationEntry(const MoneroTransactionDestinationEntry& from);

  inline MoneroTransactionDestinationEntry& operator=(const MoneroTransactionDestinationEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionDestinationEntry& default_instance();

  void Swap(MoneroTransactionDestinationEntry* other);

  // implements Message ----------------------------------------------

  MoneroTransactionDestinationEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionDestinationEntry& from);
  void MergeFrom(const MoneroTransactionDestinationEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionDestinationEntry_MoneroAccountPublicAddress MoneroAccountPublicAddress;

  // accessors -------------------------------------------------------

  // optional uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& addr() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* mutable_addr();
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* release_addr();
  inline void set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr);

  // optional bool is_subaddress = 3;
  inline bool has_is_subaddress() const;
  inline void clear_is_subaddress();
  static const int kIsSubaddressFieldNumber = 3;
  inline bool is_subaddress() const;
  inline void set_is_subaddress(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionDestinationEntry)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_is_subaddress();
  inline void clear_has_is_subaddress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 amount_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr_;
  bool is_subaddress_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionDestinationEntry* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest_MoneroTransactionData : public ::google::protobuf::Message {
 public:
  MoneroTransactionInitRequest_MoneroTransactionData();
  virtual ~MoneroTransactionInitRequest_MoneroTransactionData();

  MoneroTransactionInitRequest_MoneroTransactionData(const MoneroTransactionInitRequest_MoneroTransactionData& from);

  inline MoneroTransactionInitRequest_MoneroTransactionData& operator=(const MoneroTransactionInitRequest_MoneroTransactionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInitRequest_MoneroTransactionData& default_instance();

  void Swap(MoneroTransactionInitRequest_MoneroTransactionData* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInitRequest_MoneroTransactionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  void MergeFrom(const MoneroTransactionInitRequest_MoneroTransactionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional bytes payment_id = 2;
  inline bool has_payment_id() const;
  inline void clear_payment_id();
  static const int kPaymentIdFieldNumber = 2;
  inline const ::std::string& payment_id() const;
  inline void set_payment_id(const ::std::string& value);
  inline void set_payment_id(const char* value);
  inline void set_payment_id(const void* value, size_t size);
  inline ::std::string* mutable_payment_id();
  inline ::std::string* release_payment_id();
  inline void set_allocated_payment_id(::std::string* payment_id);

  // optional uint64 unlock_time = 3;
  inline bool has_unlock_time() const;
  inline void clear_unlock_time();
  static const int kUnlockTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 unlock_time() const;
  inline void set_unlock_time(::google::protobuf::uint64 value);

  // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& outputs(int index) const;
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_outputs(int index);
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
      mutable_outputs();

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
  inline bool has_change_dts() const;
  inline void clear_change_dts();
  static const int kChangeDtsFieldNumber = 5;
  inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& change_dts() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_change_dts();
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_change_dts();
  inline void set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts);

  // optional uint32 num_inputs = 6;
  inline bool has_num_inputs() const;
  inline void clear_num_inputs();
  static const int kNumInputsFieldNumber = 6;
  inline ::google::protobuf::uint32 num_inputs() const;
  inline void set_num_inputs(::google::protobuf::uint32 value);

  // optional uint32 mixin = 7;
  inline bool has_mixin() const;
  inline void clear_mixin();
  static const int kMixinFieldNumber = 7;
  inline ::google::protobuf::uint32 mixin() const;
  inline void set_mixin(::google::protobuf::uint32 value);

  // optional uint64 fee = 8;
  inline bool has_fee() const;
  inline void clear_fee();
  static const int kFeeFieldNumber = 8;
  inline ::google::protobuf::uint64 fee() const;
  inline void set_fee(::google::protobuf::uint64 value);

  // optional uint32 account = 9;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 9;
  inline ::google::protobuf::uint32 account() const;
  inline void set_account(::google::protobuf::uint32 value);

  // repeated uint32 minor_indices = 10;
  inline int minor_indices_size() const;
  inline void clear_minor_indices();
  static const int kMinorIndicesFieldNumber = 10;
  inline ::google::protobuf::uint32 minor_indices(int index) const;
  inline void set_minor_indices(int index, ::google::protobuf::uint32 value);
  inline void add_minor_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      minor_indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_minor_indices();

  // optional bool is_multisig = 11;
  inline bool has_is_multisig() const;
  inline void clear_is_multisig();
  static const int kIsMultisigFieldNumber = 11;
  inline bool is_multisig() const;
  inline void set_is_multisig(bool value);

  // optional bytes exp_tx_prefix_hash = 12;
  inline bool has_exp_tx_prefix_hash() const;
  inline void clear_exp_tx_prefix_hash();
  static const int kExpTxPrefixHashFieldNumber = 12;
  inline const ::std::string& exp_tx_prefix_hash() const;
  inline void set_exp_tx_prefix_hash(const ::std::string& value);
  inline void set_exp_tx_prefix_hash(const char* value);
  inline void set_exp_tx_prefix_hash(const void* value, size_t size);
  inline ::std::string* mutable_exp_tx_prefix_hash();
  inline ::std::string* release_exp_tx_prefix_hash();
  inline void set_allocated_exp_tx_prefix_hash(::std::string* exp_tx_prefix_hash);

  // repeated bytes use_tx_keys = 13;
  inline int use_tx_keys_size() const;
  inline void clear_use_tx_keys();
  static const int kUseTxKeysFieldNumber = 13;
  inline const ::std::string& use_tx_keys(int index) const;
  inline ::std::string* mutable_use_tx_keys(int index);
  inline void set_use_tx_keys(int index, const ::std::string& value);
  inline void set_use_tx_keys(int index, const char* value);
  inline void set_use_tx_keys(int index, const void* value, size_t size);
  inline ::std::string* add_use_tx_keys();
  inline void add_use_tx_keys(const ::std::string& value);
  inline void add_use_tx_keys(const char* value);
  inline void add_use_tx_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& use_tx_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_use_tx_keys();

  // optional bool is_bulletproof = 14;
  inline bool has_is_bulletproof() const;
  inline void clear_is_bulletproof();
  static const int kIsBulletproofFieldNumber = 14;
  inline bool is_bulletproof() const;
  inline void set_is_bulletproof(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_payment_id();
  inline void clear_has_payment_id();
  inline void set_has_unlock_time();
  inline void clear_has_unlock_time();
  inline void set_has_change_dts();
  inline void clear_has_change_dts();
  inline void set_has_num_inputs();
  inline void clear_has_num_inputs();
  inline void set_has_mixin();
  inline void clear_has_mixin();
  inline void set_has_fee();
  inline void clear_has_fee();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_is_multisig();
  inline void clear_has_is_multisig();
  inline void set_has_exp_tx_prefix_hash();
  inline void clear_has_exp_tx_prefix_hash();
  inline void set_has_is_bulletproof();
  inline void clear_has_is_bulletproof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* payment_id_;
  ::google::protobuf::uint64 unlock_time_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 num_inputs_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry > outputs_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts_;
  ::google::protobuf::uint64 fee_;
  ::google::protobuf::uint32 mixin_;
  ::google::protobuf::uint32 account_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > minor_indices_;
  ::std::string* exp_tx_prefix_hash_;
  ::google::protobuf::RepeatedPtrField< ::std::string> use_tx_keys_;
  bool is_multisig_;
  bool is_bulletproof_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInitRequest_MoneroTransactionData* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInitRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionInitRequest();
  virtual ~MoneroTransactionInitRequest();

  MoneroTransactionInitRequest(const MoneroTransactionInitRequest& from);

  inline MoneroTransactionInitRequest& operator=(const MoneroTransactionInitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInitRequest& default_instance();

  void Swap(MoneroTransactionInitRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInitRequest& from);
  void MergeFrom(const MoneroTransactionInitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionInitRequest_MoneroTransactionData MoneroTransactionData;

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network_type = 3;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 network_type() const;
  inline void set_network_type(::google::protobuf::uint32 value);

  // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
  inline bool has_tsx_data() const;
  inline void clear_tsx_data();
  static const int kTsxDataFieldNumber = 4;
  inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& tsx_data() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* mutable_tsx_data();
  inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* release_tsx_data();
  inline void set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_network_type();
  inline void clear_has_network_type();
  inline void set_has_tsx_data();
  inline void clear_has_tsx_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 network_type_;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInitRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInitAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionInitAck();
  virtual ~MoneroTransactionInitAck();

  MoneroTransactionInitAck(const MoneroTransactionInitAck& from);

  inline MoneroTransactionInitAck& operator=(const MoneroTransactionInitAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInitAck& default_instance();

  void Swap(MoneroTransactionInitAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInitAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInitAck& from);
  void MergeFrom(const MoneroTransactionInitAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional bool in_memory = 3;
  inline bool has_in_memory() const;
  inline void clear_in_memory();
  static const int kInMemoryFieldNumber = 3;
  inline bool in_memory() const;
  inline void set_in_memory(bool value);

  // repeated bytes hmacs = 4;
  inline int hmacs_size() const;
  inline void clear_hmacs();
  static const int kHmacsFieldNumber = 4;
  inline const ::std::string& hmacs(int index) const;
  inline ::std::string* mutable_hmacs(int index);
  inline void set_hmacs(int index, const ::std::string& value);
  inline void set_hmacs(int index, const char* value);
  inline void set_hmacs(int index, const void* value, size_t size);
  inline ::std::string* add_hmacs();
  inline void add_hmacs(const ::std::string& value);
  inline void add_hmacs(const char* value);
  inline void add_hmacs(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hmacs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hmacs();

  // optional bool many_inputs = 5;
  inline bool has_many_inputs() const;
  inline void clear_many_inputs();
  static const int kManyInputsFieldNumber = 5;
  inline bool many_inputs() const;
  inline void set_many_inputs(bool value);

  // optional bool many_outputs = 6;
  inline bool has_many_outputs() const;
  inline void clear_many_outputs();
  static const int kManyOutputsFieldNumber = 6;
  inline bool many_outputs() const;
  inline void set_many_outputs(bool value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInitAck)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_in_memory();
  inline void clear_has_in_memory();
  inline void set_has_many_inputs();
  inline void clear_has_many_inputs();
  inline void set_has_many_outputs();
  inline void clear_has_many_outputs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hmacs_;
  bool in_memory_;
  bool many_inputs_;
  bool many_outputs_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInitAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroRctKey : public ::google::protobuf::Message {
 public:
  MoneroTransactionSourceEntry_MoneroRctKey();
  virtual ~MoneroTransactionSourceEntry_MoneroRctKey();

  MoneroTransactionSourceEntry_MoneroRctKey(const MoneroTransactionSourceEntry_MoneroRctKey& from);

  inline MoneroTransactionSourceEntry_MoneroRctKey& operator=(const MoneroTransactionSourceEntry_MoneroRctKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSourceEntry_MoneroRctKey& default_instance();

  void Swap(MoneroTransactionSourceEntry_MoneroRctKey* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroRctKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroRctKey& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroRctKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dest = 1;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 1;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const void* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // optional bytes mask = 2;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 2;
  inline const ::std::string& mask() const;
  inline void set_mask(const ::std::string& value);
  inline void set_mask(const char* value);
  inline void set_mask(const void* value, size_t size);
  inline ::std::string* mutable_mask();
  inline ::std::string* release_mask();
  inline void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey)
 private:
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_mask();
  inline void clear_has_mask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* dest_;
  ::std::string* mask_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSourceEntry_MoneroRctKey* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroOutputEntry : public ::google::protobuf::Message {
 public:
  MoneroTransactionSourceEntry_MoneroOutputEntry();
  virtual ~MoneroTransactionSourceEntry_MoneroOutputEntry();

  MoneroTransactionSourceEntry_MoneroOutputEntry(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);

  inline MoneroTransactionSourceEntry_MoneroOutputEntry& operator=(const MoneroTransactionSourceEntry_MoneroOutputEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSourceEntry_MoneroOutputEntry& default_instance();

  void Swap(MoneroTransactionSourceEntry_MoneroOutputEntry* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroOutputEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroOutputEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey& key() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* mutable_key();
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* release_key();
  inline void set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 amount_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* key_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSourceEntry_MoneroOutputEntry* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry_MoneroMultisigKLRki : public ::google::protobuf::Message {
 public:
  MoneroTransactionSourceEntry_MoneroMultisigKLRki();
  virtual ~MoneroTransactionSourceEntry_MoneroMultisigKLRki();

  MoneroTransactionSourceEntry_MoneroMultisigKLRki(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);

  inline MoneroTransactionSourceEntry_MoneroMultisigKLRki& operator=(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSourceEntry_MoneroMultisigKLRki& default_instance();

  void Swap(MoneroTransactionSourceEntry_MoneroMultisigKLRki* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry_MoneroMultisigKLRki* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  void MergeFrom(const MoneroTransactionSourceEntry_MoneroMultisigKLRki& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes K = 1;
  inline bool has_k() const;
  inline void clear_k();
  static const int kKFieldNumber = 1;
  inline const ::std::string& k() const;
  inline void set_k(const ::std::string& value);
  inline void set_k(const char* value);
  inline void set_k(const void* value, size_t size);
  inline ::std::string* mutable_k();
  inline ::std::string* release_k();
  inline void set_allocated_k(::std::string* k);

  // optional bytes L = 2;
  inline bool has_l() const;
  inline void clear_l();
  static const int kLFieldNumber = 2;
  inline const ::std::string& l() const;
  inline void set_l(const ::std::string& value);
  inline void set_l(const char* value);
  inline void set_l(const void* value, size_t size);
  inline ::std::string* mutable_l();
  inline ::std::string* release_l();
  inline void set_allocated_l(::std::string* l);

  // optional bytes R = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline const ::std::string& r() const;
  inline void set_r(const ::std::string& value);
  inline void set_r(const char* value);
  inline void set_r(const void* value, size_t size);
  inline ::std::string* mutable_r();
  inline ::std::string* release_r();
  inline void set_allocated_r(::std::string* r);

  // optional bytes ki = 4;
  inline bool has_ki() const;
  inline void clear_ki();
  static const int kKiFieldNumber = 4;
  inline const ::std::string& ki() const;
  inline void set_ki(const ::std::string& value);
  inline void set_ki(const char* value);
  inline void set_ki(const void* value, size_t size);
  inline ::std::string* mutable_ki();
  inline ::std::string* release_ki();
  inline void set_allocated_ki(::std::string* ki);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki)
 private:
  inline void set_has_k();
  inline void clear_has_k();
  inline void set_has_l();
  inline void clear_has_l();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_ki();
  inline void clear_has_ki();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* k_;
  ::std::string* l_;
  ::std::string* r_;
  ::std::string* ki_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSourceEntry_MoneroMultisigKLRki* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSourceEntry : public ::google::protobuf::Message {
 public:
  MoneroTransactionSourceEntry();
  virtual ~MoneroTransactionSourceEntry();

  MoneroTransactionSourceEntry(const MoneroTransactionSourceEntry& from);

  inline MoneroTransactionSourceEntry& operator=(const MoneroTransactionSourceEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSourceEntry& default_instance();

  void Swap(MoneroTransactionSourceEntry* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSourceEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSourceEntry& from);
  void MergeFrom(const MoneroTransactionSourceEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionSourceEntry_MoneroRctKey MoneroRctKey;
  typedef MoneroTransactionSourceEntry_MoneroOutputEntry MoneroOutputEntry;
  typedef MoneroTransactionSourceEntry_MoneroMultisigKLRki MoneroMultisigKLRki;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& outputs(int index) const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* mutable_outputs(int index);
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
      mutable_outputs();

  // optional uint64 real_output = 2;
  inline bool has_real_output() const;
  inline void clear_real_output();
  static const int kRealOutputFieldNumber = 2;
  inline ::google::protobuf::uint64 real_output() const;
  inline void set_real_output(::google::protobuf::uint64 value);

  // optional bytes real_out_tx_key = 3;
  inline bool has_real_out_tx_key() const;
  inline void clear_real_out_tx_key();
  static const int kRealOutTxKeyFieldNumber = 3;
  inline const ::std::string& real_out_tx_key() const;
  inline void set_real_out_tx_key(const ::std::string& value);
  inline void set_real_out_tx_key(const char* value);
  inline void set_real_out_tx_key(const void* value, size_t size);
  inline ::std::string* mutable_real_out_tx_key();
  inline ::std::string* release_real_out_tx_key();
  inline void set_allocated_real_out_tx_key(::std::string* real_out_tx_key);

  // repeated bytes real_out_additional_tx_keys = 4;
  inline int real_out_additional_tx_keys_size() const;
  inline void clear_real_out_additional_tx_keys();
  static const int kRealOutAdditionalTxKeysFieldNumber = 4;
  inline const ::std::string& real_out_additional_tx_keys(int index) const;
  inline ::std::string* mutable_real_out_additional_tx_keys(int index);
  inline void set_real_out_additional_tx_keys(int index, const ::std::string& value);
  inline void set_real_out_additional_tx_keys(int index, const char* value);
  inline void set_real_out_additional_tx_keys(int index, const void* value, size_t size);
  inline ::std::string* add_real_out_additional_tx_keys();
  inline void add_real_out_additional_tx_keys(const ::std::string& value);
  inline void add_real_out_additional_tx_keys(const char* value);
  inline void add_real_out_additional_tx_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& real_out_additional_tx_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_real_out_additional_tx_keys();

  // optional uint64 real_output_in_tx_index = 5;
  inline bool has_real_output_in_tx_index() const;
  inline void clear_real_output_in_tx_index();
  static const int kRealOutputInTxIndexFieldNumber = 5;
  inline ::google::protobuf::uint64 real_output_in_tx_index() const;
  inline void set_real_output_in_tx_index(::google::protobuf::uint64 value);

  // optional uint64 amount = 6;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 6;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // optional bool rct = 7;
  inline bool has_rct() const;
  inline void clear_rct();
  static const int kRctFieldNumber = 7;
  inline bool rct() const;
  inline void set_rct(bool value);

  // optional bytes mask = 8;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 8;
  inline const ::std::string& mask() const;
  inline void set_mask(const ::std::string& value);
  inline void set_mask(const char* value);
  inline void set_mask(const void* value, size_t size);
  inline ::std::string* mutable_mask();
  inline ::std::string* release_mask();
  inline void set_allocated_mask(::std::string* mask);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
  inline bool has_multisig_klrki() const;
  inline void clear_multisig_klrki();
  static const int kMultisigKLRkiFieldNumber = 9;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& multisig_klrki() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* mutable_multisig_klrki();
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* release_multisig_klrki();
  inline void set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSourceEntry)
 private:
  inline void set_has_real_output();
  inline void clear_has_real_output();
  inline void set_has_real_out_tx_key();
  inline void clear_has_real_out_tx_key();
  inline void set_has_real_output_in_tx_index();
  inline void clear_has_real_output_in_tx_index();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_rct();
  inline void clear_has_rct();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_multisig_klrki();
  inline void clear_has_multisig_klrki();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry > outputs_;
  ::google::protobuf::uint64 real_output_;
  ::std::string* real_out_tx_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> real_out_additional_tx_keys_;
  ::google::protobuf::uint64 real_output_in_tx_index_;
  ::google::protobuf::uint64 amount_;
  ::std::string* mask_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki_;
  bool rct_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSourceEntry* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionSetInputRequest();
  virtual ~MoneroTransactionSetInputRequest();

  MoneroTransactionSetInputRequest(const MoneroTransactionSetInputRequest& from);

  inline MoneroTransactionSetInputRequest& operator=(const MoneroTransactionSetInputRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSetInputRequest& default_instance();

  void Swap(MoneroTransactionSetInputRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSetInputRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSetInputRequest& from);
  void MergeFrom(const MoneroTransactionSetInputRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 2;
  inline bool has_src_entr() const;
  inline void clear_src_entr();
  static const int kSrcEntrFieldNumber = 2;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  inline void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_src_entr();
  inline void clear_has_src_entr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSetInputRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSetInputAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionSetInputAck();
  virtual ~MoneroTransactionSetInputAck();

  MoneroTransactionSetInputAck(const MoneroTransactionSetInputAck& from);

  inline MoneroTransactionSetInputAck& operator=(const MoneroTransactionSetInputAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSetInputAck& default_instance();

  void Swap(MoneroTransactionSetInputAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSetInputAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSetInputAck& from);
  void MergeFrom(const MoneroTransactionSetInputAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes vini = 1;
  inline bool has_vini() const;
  inline void clear_vini();
  static const int kViniFieldNumber = 1;
  inline const ::std::string& vini() const;
  inline void set_vini(const ::std::string& value);
  inline void set_vini(const char* value);
  inline void set_vini(const void* value, size_t size);
  inline ::std::string* mutable_vini();
  inline ::std::string* release_vini();
  inline void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 2;
  inline bool has_vini_hmac() const;
  inline void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 2;
  inline const ::std::string& vini_hmac() const;
  inline void set_vini_hmac(const ::std::string& value);
  inline void set_vini_hmac(const char* value);
  inline void set_vini_hmac(const void* value, size_t size);
  inline ::std::string* mutable_vini_hmac();
  inline ::std::string* release_vini_hmac();
  inline void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 3;
  inline bool has_pseudo_out() const;
  inline void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 3;
  inline const ::std::string& pseudo_out() const;
  inline void set_pseudo_out(const ::std::string& value);
  inline void set_pseudo_out(const char* value);
  inline void set_pseudo_out(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out();
  inline ::std::string* release_pseudo_out();
  inline void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 4;
  inline bool has_pseudo_out_hmac() const;
  inline void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 4;
  inline const ::std::string& pseudo_out_hmac() const;
  inline void set_pseudo_out_hmac(const ::std::string& value);
  inline void set_pseudo_out_hmac(const char* value);
  inline void set_pseudo_out_hmac(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out_hmac();
  inline ::std::string* release_pseudo_out_hmac();
  inline void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // optional bytes alpha_enc = 5;
  inline bool has_alpha_enc() const;
  inline void clear_alpha_enc();
  static const int kAlphaEncFieldNumber = 5;
  inline const ::std::string& alpha_enc() const;
  inline void set_alpha_enc(const ::std::string& value);
  inline void set_alpha_enc(const char* value);
  inline void set_alpha_enc(const void* value, size_t size);
  inline ::std::string* mutable_alpha_enc();
  inline ::std::string* release_alpha_enc();
  inline void set_allocated_alpha_enc(::std::string* alpha_enc);

  // optional bytes spend_enc = 6;
  inline bool has_spend_enc() const;
  inline void clear_spend_enc();
  static const int kSpendEncFieldNumber = 6;
  inline const ::std::string& spend_enc() const;
  inline void set_spend_enc(const ::std::string& value);
  inline void set_spend_enc(const char* value);
  inline void set_spend_enc(const void* value, size_t size);
  inline ::std::string* mutable_spend_enc();
  inline ::std::string* release_spend_enc();
  inline void set_allocated_spend_enc(::std::string* spend_enc);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetInputAck)
 private:
  inline void set_has_vini();
  inline void clear_has_vini();
  inline void set_has_vini_hmac();
  inline void clear_has_vini_hmac();
  inline void set_has_pseudo_out();
  inline void clear_has_pseudo_out();
  inline void set_has_pseudo_out_hmac();
  inline void clear_has_pseudo_out_hmac();
  inline void set_has_alpha_enc();
  inline void clear_has_alpha_enc();
  inline void set_has_spend_enc();
  inline void clear_has_spend_enc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* vini_;
  ::std::string* vini_hmac_;
  ::std::string* pseudo_out_;
  ::std::string* pseudo_out_hmac_;
  ::std::string* alpha_enc_;
  ::std::string* spend_enc_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSetInputAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInputsPermutationRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionInputsPermutationRequest();
  virtual ~MoneroTransactionInputsPermutationRequest();

  MoneroTransactionInputsPermutationRequest(const MoneroTransactionInputsPermutationRequest& from);

  inline MoneroTransactionInputsPermutationRequest& operator=(const MoneroTransactionInputsPermutationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInputsPermutationRequest& default_instance();

  void Swap(MoneroTransactionInputsPermutationRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInputsPermutationRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInputsPermutationRequest& from);
  void MergeFrom(const MoneroTransactionInputsPermutationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 perm = 1;
  inline int perm_size() const;
  inline void clear_perm();
  static const int kPermFieldNumber = 1;
  inline ::google::protobuf::uint32 perm(int index) const;
  inline void set_perm(int index, ::google::protobuf::uint32 value);
  inline void add_perm(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      perm() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_perm();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > perm_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInputsPermutationRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInputsPermutationAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionInputsPermutationAck();
  virtual ~MoneroTransactionInputsPermutationAck();

  MoneroTransactionInputsPermutationAck(const MoneroTransactionInputsPermutationAck& from);

  inline MoneroTransactionInputsPermutationAck& operator=(const MoneroTransactionInputsPermutationAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInputsPermutationAck& default_instance();

  void Swap(MoneroTransactionInputsPermutationAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInputsPermutationAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInputsPermutationAck& from);
  void MergeFrom(const MoneroTransactionInputsPermutationAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputsPermutationAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInputsPermutationAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionInputViniRequest();
  virtual ~MoneroTransactionInputViniRequest();

  MoneroTransactionInputViniRequest(const MoneroTransactionInputViniRequest& from);

  inline MoneroTransactionInputViniRequest& operator=(const MoneroTransactionInputViniRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInputViniRequest& default_instance();

  void Swap(MoneroTransactionInputViniRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInputViniRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInputViniRequest& from);
  void MergeFrom(const MoneroTransactionInputViniRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  inline bool has_src_entr() const;
  inline void clear_src_entr();
  static const int kSrcEntrFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  inline void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // optional bytes vini = 2;
  inline bool has_vini() const;
  inline void clear_vini();
  static const int kViniFieldNumber = 2;
  inline const ::std::string& vini() const;
  inline void set_vini(const ::std::string& value);
  inline void set_vini(const char* value);
  inline void set_vini(const void* value, size_t size);
  inline ::std::string* mutable_vini();
  inline ::std::string* release_vini();
  inline void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 3;
  inline bool has_vini_hmac() const;
  inline void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 3;
  inline const ::std::string& vini_hmac() const;
  inline void set_vini_hmac(const ::std::string& value);
  inline void set_vini_hmac(const char* value);
  inline void set_vini_hmac(const void* value, size_t size);
  inline ::std::string* mutable_vini_hmac();
  inline ::std::string* release_vini_hmac();
  inline void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 4;
  inline bool has_pseudo_out() const;
  inline void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 4;
  inline const ::std::string& pseudo_out() const;
  inline void set_pseudo_out(const ::std::string& value);
  inline void set_pseudo_out(const char* value);
  inline void set_pseudo_out(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out();
  inline ::std::string* release_pseudo_out();
  inline void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 5;
  inline bool has_pseudo_out_hmac() const;
  inline void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 5;
  inline const ::std::string& pseudo_out_hmac() const;
  inline void set_pseudo_out_hmac(const ::std::string& value);
  inline void set_pseudo_out_hmac(const char* value);
  inline void set_pseudo_out_hmac(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out_hmac();
  inline ::std::string* release_pseudo_out_hmac();
  inline void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniRequest)
 private:
  inline void set_has_src_entr();
  inline void clear_has_src_entr();
  inline void set_has_vini();
  inline void clear_has_vini();
  inline void set_has_vini_hmac();
  inline void clear_has_vini_hmac();
  inline void set_has_pseudo_out();
  inline void clear_has_pseudo_out();
  inline void set_has_pseudo_out_hmac();
  inline void clear_has_pseudo_out_hmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  ::std::string* vini_;
  ::std::string* vini_hmac_;
  ::std::string* pseudo_out_;
  ::std::string* pseudo_out_hmac_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInputViniRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionInputViniAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionInputViniAck();
  virtual ~MoneroTransactionInputViniAck();

  MoneroTransactionInputViniAck(const MoneroTransactionInputViniAck& from);

  inline MoneroTransactionInputViniAck& operator=(const MoneroTransactionInputViniAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionInputViniAck& default_instance();

  void Swap(MoneroTransactionInputViniAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionInputViniAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionInputViniAck& from);
  void MergeFrom(const MoneroTransactionInputViniAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionInputViniAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionInputViniAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionSetOutputRequest();
  virtual ~MoneroTransactionSetOutputRequest();

  MoneroTransactionSetOutputRequest(const MoneroTransactionSetOutputRequest& from);

  inline MoneroTransactionSetOutputRequest& operator=(const MoneroTransactionSetOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSetOutputRequest& default_instance();

  void Swap(MoneroTransactionSetOutputRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSetOutputRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSetOutputRequest& from);
  void MergeFrom(const MoneroTransactionSetOutputRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
  inline bool has_dst_entr() const;
  inline void clear_dst_entr();
  static const int kDstEntrFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& dst_entr() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* mutable_dst_entr();
  inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* release_dst_entr();
  inline void set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr);

  // optional bytes dst_entr_hmac = 2;
  inline bool has_dst_entr_hmac() const;
  inline void clear_dst_entr_hmac();
  static const int kDstEntrHmacFieldNumber = 2;
  inline const ::std::string& dst_entr_hmac() const;
  inline void set_dst_entr_hmac(const ::std::string& value);
  inline void set_dst_entr_hmac(const char* value);
  inline void set_dst_entr_hmac(const void* value, size_t size);
  inline ::std::string* mutable_dst_entr_hmac();
  inline ::std::string* release_dst_entr_hmac();
  inline void set_allocated_dst_entr_hmac(::std::string* dst_entr_hmac);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest)
 private:
  inline void set_has_dst_entr();
  inline void clear_has_dst_entr();
  inline void set_has_dst_entr_hmac();
  inline void clear_has_dst_entr_hmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr_;
  ::std::string* dst_entr_hmac_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSetOutputRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSetOutputAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionSetOutputAck();
  virtual ~MoneroTransactionSetOutputAck();

  MoneroTransactionSetOutputAck(const MoneroTransactionSetOutputAck& from);

  inline MoneroTransactionSetOutputAck& operator=(const MoneroTransactionSetOutputAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSetOutputAck& default_instance();

  void Swap(MoneroTransactionSetOutputAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSetOutputAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSetOutputAck& from);
  void MergeFrom(const MoneroTransactionSetOutputAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_out = 1;
  inline bool has_tx_out() const;
  inline void clear_tx_out();
  static const int kTxOutFieldNumber = 1;
  inline const ::std::string& tx_out() const;
  inline void set_tx_out(const ::std::string& value);
  inline void set_tx_out(const char* value);
  inline void set_tx_out(const void* value, size_t size);
  inline ::std::string* mutable_tx_out();
  inline ::std::string* release_tx_out();
  inline void set_allocated_tx_out(::std::string* tx_out);

  // optional bytes vouti_hmac = 2;
  inline bool has_vouti_hmac() const;
  inline void clear_vouti_hmac();
  static const int kVoutiHmacFieldNumber = 2;
  inline const ::std::string& vouti_hmac() const;
  inline void set_vouti_hmac(const ::std::string& value);
  inline void set_vouti_hmac(const char* value);
  inline void set_vouti_hmac(const void* value, size_t size);
  inline ::std::string* mutable_vouti_hmac();
  inline ::std::string* release_vouti_hmac();
  inline void set_allocated_vouti_hmac(::std::string* vouti_hmac);

  // optional bytes rsig = 3;
  inline bool has_rsig() const;
  inline void clear_rsig();
  static const int kRsigFieldNumber = 3;
  inline const ::std::string& rsig() const;
  inline void set_rsig(const ::std::string& value);
  inline void set_rsig(const char* value);
  inline void set_rsig(const void* value, size_t size);
  inline ::std::string* mutable_rsig();
  inline ::std::string* release_rsig();
  inline void set_allocated_rsig(::std::string* rsig);

  // optional bytes out_pk = 4;
  inline bool has_out_pk() const;
  inline void clear_out_pk();
  static const int kOutPkFieldNumber = 4;
  inline const ::std::string& out_pk() const;
  inline void set_out_pk(const ::std::string& value);
  inline void set_out_pk(const char* value);
  inline void set_out_pk(const void* value, size_t size);
  inline ::std::string* mutable_out_pk();
  inline ::std::string* release_out_pk();
  inline void set_allocated_out_pk(::std::string* out_pk);

  // optional bytes ecdh_info = 5;
  inline bool has_ecdh_info() const;
  inline void clear_ecdh_info();
  static const int kEcdhInfoFieldNumber = 5;
  inline const ::std::string& ecdh_info() const;
  inline void set_ecdh_info(const ::std::string& value);
  inline void set_ecdh_info(const char* value);
  inline void set_ecdh_info(const void* value, size_t size);
  inline ::std::string* mutable_ecdh_info();
  inline ::std::string* release_ecdh_info();
  inline void set_allocated_ecdh_info(::std::string* ecdh_info);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSetOutputAck)
 private:
  inline void set_has_tx_out();
  inline void clear_has_tx_out();
  inline void set_has_vouti_hmac();
  inline void clear_has_vouti_hmac();
  inline void set_has_rsig();
  inline void clear_has_rsig();
  inline void set_has_out_pk();
  inline void clear_has_out_pk();
  inline void set_has_ecdh_info();
  inline void clear_has_ecdh_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tx_out_;
  ::std::string* vouti_hmac_;
  ::std::string* rsig_;
  ::std::string* out_pk_;
  ::std::string* ecdh_info_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSetOutputAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionAllOutSetRequest();
  virtual ~MoneroTransactionAllOutSetRequest();

  MoneroTransactionAllOutSetRequest(const MoneroTransactionAllOutSetRequest& from);

  inline MoneroTransactionAllOutSetRequest& operator=(const MoneroTransactionAllOutSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionAllOutSetRequest& default_instance();

  void Swap(MoneroTransactionAllOutSetRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionAllOutSetRequest& from);
  void MergeFrom(const MoneroTransactionAllOutSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionAllOutSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck_MoneroRingCtSig : public ::google::protobuf::Message {
 public:
  MoneroTransactionAllOutSetAck_MoneroRingCtSig();
  virtual ~MoneroTransactionAllOutSetAck_MoneroRingCtSig();

  MoneroTransactionAllOutSetAck_MoneroRingCtSig(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);

  inline MoneroTransactionAllOutSetAck_MoneroRingCtSig& operator=(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionAllOutSetAck_MoneroRingCtSig& default_instance();

  void Swap(MoneroTransactionAllOutSetAck_MoneroRingCtSig* other);

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetAck_MoneroRingCtSig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  void MergeFrom(const MoneroTransactionAllOutSetAck_MoneroRingCtSig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 txn_fee = 1;
  inline bool has_txn_fee() const;
  inline void clear_txn_fee();
  static const int kTxnFeeFieldNumber = 1;
  inline ::google::protobuf::uint64 txn_fee() const;
  inline void set_txn_fee(::google::protobuf::uint64 value);

  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional uint32 rv_type = 3;
  inline bool has_rv_type() const;
  inline void clear_rv_type();
  static const int kRvTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 rv_type() const;
  inline void set_rv_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig)
 private:
  inline void set_has_txn_fee();
  inline void clear_has_txn_fee();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_rv_type();
  inline void clear_has_rv_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 txn_fee_;
  ::std::string* message_;
  ::google::protobuf::uint32 rv_type_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionAllOutSetAck_MoneroRingCtSig* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionAllOutSetAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionAllOutSetAck();
  virtual ~MoneroTransactionAllOutSetAck();

  MoneroTransactionAllOutSetAck(const MoneroTransactionAllOutSetAck& from);

  inline MoneroTransactionAllOutSetAck& operator=(const MoneroTransactionAllOutSetAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionAllOutSetAck& default_instance();

  void Swap(MoneroTransactionAllOutSetAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionAllOutSetAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionAllOutSetAck& from);
  void MergeFrom(const MoneroTransactionAllOutSetAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroTransactionAllOutSetAck_MoneroRingCtSig MoneroRingCtSig;

  // accessors -------------------------------------------------------

  // optional bytes extra = 1;
  inline bool has_extra() const;
  inline void clear_extra();
  static const int kExtraFieldNumber = 1;
  inline const ::std::string& extra() const;
  inline void set_extra(const ::std::string& value);
  inline void set_extra(const char* value);
  inline void set_extra(const void* value, size_t size);
  inline ::std::string* mutable_extra();
  inline ::std::string* release_extra();
  inline void set_allocated_extra(::std::string* extra);

  // optional bytes tx_prefix_hash = 2;
  inline bool has_tx_prefix_hash() const;
  inline void clear_tx_prefix_hash();
  static const int kTxPrefixHashFieldNumber = 2;
  inline const ::std::string& tx_prefix_hash() const;
  inline void set_tx_prefix_hash(const ::std::string& value);
  inline void set_tx_prefix_hash(const char* value);
  inline void set_tx_prefix_hash(const void* value, size_t size);
  inline ::std::string* mutable_tx_prefix_hash();
  inline ::std::string* release_tx_prefix_hash();
  inline void set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash);

  // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 3;
  inline bool has_rv() const;
  inline void clear_rv();
  static const int kRvFieldNumber = 3;
  inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& rv() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* mutable_rv();
  inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* release_rv();
  inline void set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck)
 private:
  inline void set_has_extra();
  inline void clear_has_extra();
  inline void set_has_tx_prefix_hash();
  inline void clear_has_tx_prefix_hash();
  inline void set_has_rv();
  inline void clear_has_rv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* extra_;
  ::std::string* tx_prefix_hash_;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionAllOutSetAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionMlsagDoneRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionMlsagDoneRequest();
  virtual ~MoneroTransactionMlsagDoneRequest();

  MoneroTransactionMlsagDoneRequest(const MoneroTransactionMlsagDoneRequest& from);

  inline MoneroTransactionMlsagDoneRequest& operator=(const MoneroTransactionMlsagDoneRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionMlsagDoneRequest& default_instance();

  void Swap(MoneroTransactionMlsagDoneRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionMlsagDoneRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionMlsagDoneRequest& from);
  void MergeFrom(const MoneroTransactionMlsagDoneRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionMlsagDoneRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionMlsagDoneRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionMlsagDoneAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionMlsagDoneAck();
  virtual ~MoneroTransactionMlsagDoneAck();

  MoneroTransactionMlsagDoneAck(const MoneroTransactionMlsagDoneAck& from);

  inline MoneroTransactionMlsagDoneAck& operator=(const MoneroTransactionMlsagDoneAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionMlsagDoneAck& default_instance();

  void Swap(MoneroTransactionMlsagDoneAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionMlsagDoneAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionMlsagDoneAck& from);
  void MergeFrom(const MoneroTransactionMlsagDoneAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes full_message_hash = 1;
  inline bool has_full_message_hash() const;
  inline void clear_full_message_hash();
  static const int kFullMessageHashFieldNumber = 1;
  inline const ::std::string& full_message_hash() const;
  inline void set_full_message_hash(const ::std::string& value);
  inline void set_full_message_hash(const char* value);
  inline void set_full_message_hash(const void* value, size_t size);
  inline ::std::string* mutable_full_message_hash();
  inline ::std::string* release_full_message_hash();
  inline void set_allocated_full_message_hash(::std::string* full_message_hash);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck)
 private:
  inline void set_has_full_message_hash();
  inline void clear_has_full_message_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* full_message_hash_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionMlsagDoneAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionSignInputRequest();
  virtual ~MoneroTransactionSignInputRequest();

  MoneroTransactionSignInputRequest(const MoneroTransactionSignInputRequest& from);

  inline MoneroTransactionSignInputRequest& operator=(const MoneroTransactionSignInputRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSignInputRequest& default_instance();

  void Swap(MoneroTransactionSignInputRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSignInputRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSignInputRequest& from);
  void MergeFrom(const MoneroTransactionSignInputRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
  inline bool has_src_entr() const;
  inline void clear_src_entr();
  static const int kSrcEntrFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& src_entr() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* mutable_src_entr();
  inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* release_src_entr();
  inline void set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr);

  // optional bytes vini = 2;
  inline bool has_vini() const;
  inline void clear_vini();
  static const int kViniFieldNumber = 2;
  inline const ::std::string& vini() const;
  inline void set_vini(const ::std::string& value);
  inline void set_vini(const char* value);
  inline void set_vini(const void* value, size_t size);
  inline ::std::string* mutable_vini();
  inline ::std::string* release_vini();
  inline void set_allocated_vini(::std::string* vini);

  // optional bytes vini_hmac = 3;
  inline bool has_vini_hmac() const;
  inline void clear_vini_hmac();
  static const int kViniHmacFieldNumber = 3;
  inline const ::std::string& vini_hmac() const;
  inline void set_vini_hmac(const ::std::string& value);
  inline void set_vini_hmac(const char* value);
  inline void set_vini_hmac(const void* value, size_t size);
  inline ::std::string* mutable_vini_hmac();
  inline ::std::string* release_vini_hmac();
  inline void set_allocated_vini_hmac(::std::string* vini_hmac);

  // optional bytes pseudo_out = 4;
  inline bool has_pseudo_out() const;
  inline void clear_pseudo_out();
  static const int kPseudoOutFieldNumber = 4;
  inline const ::std::string& pseudo_out() const;
  inline void set_pseudo_out(const ::std::string& value);
  inline void set_pseudo_out(const char* value);
  inline void set_pseudo_out(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out();
  inline ::std::string* release_pseudo_out();
  inline void set_allocated_pseudo_out(::std::string* pseudo_out);

  // optional bytes pseudo_out_hmac = 5;
  inline bool has_pseudo_out_hmac() const;
  inline void clear_pseudo_out_hmac();
  static const int kPseudoOutHmacFieldNumber = 5;
  inline const ::std::string& pseudo_out_hmac() const;
  inline void set_pseudo_out_hmac(const ::std::string& value);
  inline void set_pseudo_out_hmac(const char* value);
  inline void set_pseudo_out_hmac(const void* value, size_t size);
  inline ::std::string* mutable_pseudo_out_hmac();
  inline ::std::string* release_pseudo_out_hmac();
  inline void set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac);

  // optional bytes alpha_enc = 6;
  inline bool has_alpha_enc() const;
  inline void clear_alpha_enc();
  static const int kAlphaEncFieldNumber = 6;
  inline const ::std::string& alpha_enc() const;
  inline void set_alpha_enc(const ::std::string& value);
  inline void set_alpha_enc(const char* value);
  inline void set_alpha_enc(const void* value, size_t size);
  inline ::std::string* mutable_alpha_enc();
  inline ::std::string* release_alpha_enc();
  inline void set_allocated_alpha_enc(::std::string* alpha_enc);

  // optional bytes spend_enc = 7;
  inline bool has_spend_enc() const;
  inline void clear_spend_enc();
  static const int kSpendEncFieldNumber = 7;
  inline const ::std::string& spend_enc() const;
  inline void set_spend_enc(const ::std::string& value);
  inline void set_spend_enc(const char* value);
  inline void set_spend_enc(const void* value, size_t size);
  inline ::std::string* mutable_spend_enc();
  inline ::std::string* release_spend_enc();
  inline void set_allocated_spend_enc(::std::string* spend_enc);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputRequest)
 private:
  inline void set_has_src_entr();
  inline void clear_has_src_entr();
  inline void set_has_vini();
  inline void clear_has_vini();
  inline void set_has_vini_hmac();
  inline void clear_has_vini_hmac();
  inline void set_has_pseudo_out();
  inline void clear_has_pseudo_out();
  inline void set_has_pseudo_out_hmac();
  inline void clear_has_pseudo_out_hmac();
  inline void set_has_alpha_enc();
  inline void clear_has_alpha_enc();
  inline void set_has_spend_enc();
  inline void clear_has_spend_enc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr_;
  ::std::string* vini_;
  ::std::string* vini_hmac_;
  ::std::string* pseudo_out_;
  ::std::string* pseudo_out_hmac_;
  ::std::string* alpha_enc_;
  ::std::string* spend_enc_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSignInputRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSignInputAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionSignInputAck();
  virtual ~MoneroTransactionSignInputAck();

  MoneroTransactionSignInputAck(const MoneroTransactionSignInputAck& from);

  inline MoneroTransactionSignInputAck& operator=(const MoneroTransactionSignInputAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSignInputAck& default_instance();

  void Swap(MoneroTransactionSignInputAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSignInputAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSignInputAck& from);
  void MergeFrom(const MoneroTransactionSignInputAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 1;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 1;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes cout = 2;
  inline bool has_cout() const;
  inline void clear_cout();
  static const int kCoutFieldNumber = 2;
  inline const ::std::string& cout() const;
  inline void set_cout(const ::std::string& value);
  inline void set_cout(const char* value);
  inline void set_cout(const void* value, size_t size);
  inline ::std::string* mutable_cout();
  inline ::std::string* release_cout();
  inline void set_allocated_cout(::std::string* cout);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignInputAck)
 private:
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_cout();
  inline void clear_has_cout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* signature_;
  ::std::string* cout_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSignInputAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionFinalRequest();
  virtual ~MoneroTransactionFinalRequest();

  MoneroTransactionFinalRequest(const MoneroTransactionFinalRequest& from);

  inline MoneroTransactionFinalRequest& operator=(const MoneroTransactionFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionFinalRequest& default_instance();

  void Swap(MoneroTransactionFinalRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionFinalRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionFinalRequest& from);
  void MergeFrom(const MoneroTransactionFinalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionFinalRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionFinalAck : public ::google::protobuf::Message {
 public:
  MoneroTransactionFinalAck();
  virtual ~MoneroTransactionFinalAck();

  MoneroTransactionFinalAck(const MoneroTransactionFinalAck& from);

  inline MoneroTransactionFinalAck& operator=(const MoneroTransactionFinalAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionFinalAck& default_instance();

  void Swap(MoneroTransactionFinalAck* other);

  // implements Message ----------------------------------------------

  MoneroTransactionFinalAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionFinalAck& from);
  void MergeFrom(const MoneroTransactionFinalAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cout_key = 1;
  inline bool has_cout_key() const;
  inline void clear_cout_key();
  static const int kCoutKeyFieldNumber = 1;
  inline const ::std::string& cout_key() const;
  inline void set_cout_key(const ::std::string& value);
  inline void set_cout_key(const char* value);
  inline void set_cout_key(const void* value, size_t size);
  inline ::std::string* mutable_cout_key();
  inline ::std::string* release_cout_key();
  inline void set_allocated_cout_key(::std::string* cout_key);

  // optional bytes salt = 2;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 2;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  inline void set_allocated_salt(::std::string* salt);

  // optional bytes rand_mult = 3;
  inline bool has_rand_mult() const;
  inline void clear_rand_mult();
  static const int kRandMultFieldNumber = 3;
  inline const ::std::string& rand_mult() const;
  inline void set_rand_mult(const ::std::string& value);
  inline void set_rand_mult(const char* value);
  inline void set_rand_mult(const void* value, size_t size);
  inline ::std::string* mutable_rand_mult();
  inline ::std::string* release_rand_mult();
  inline void set_allocated_rand_mult(::std::string* rand_mult);

  // optional bytes tx_enc_keys = 4;
  inline bool has_tx_enc_keys() const;
  inline void clear_tx_enc_keys();
  static const int kTxEncKeysFieldNumber = 4;
  inline const ::std::string& tx_enc_keys() const;
  inline void set_tx_enc_keys(const ::std::string& value);
  inline void set_tx_enc_keys(const char* value);
  inline void set_tx_enc_keys(const void* value, size_t size);
  inline ::std::string* mutable_tx_enc_keys();
  inline ::std::string* release_tx_enc_keys();
  inline void set_allocated_tx_enc_keys(::std::string* tx_enc_keys);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionFinalAck)
 private:
  inline void set_has_cout_key();
  inline void clear_has_cout_key();
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_rand_mult();
  inline void clear_has_rand_mult();
  inline void set_has_tx_enc_keys();
  inline void clear_has_tx_enc_keys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* cout_key_;
  ::std::string* salt_;
  ::std::string* rand_mult_;
  ::std::string* tx_enc_keys_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionFinalAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroTransactionSignRequest : public ::google::protobuf::Message {
 public:
  MoneroTransactionSignRequest();
  virtual ~MoneroTransactionSignRequest();

  MoneroTransactionSignRequest(const MoneroTransactionSignRequest& from);

  inline MoneroTransactionSignRequest& operator=(const MoneroTransactionSignRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroTransactionSignRequest& default_instance();

  void Swap(MoneroTransactionSignRequest* other);

  // implements Message ----------------------------------------------

  MoneroTransactionSignRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroTransactionSignRequest& from);
  void MergeFrom(const MoneroTransactionSignRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest init = 1;
  inline bool has_init() const;
  inline void clear_init();
  static const int kInitFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest& init() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest* mutable_init();
  inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest* release_init();
  inline void set_allocated_init(::hw::trezor::messages::monero::MoneroTransactionInitRequest* init);

  // optional .hw.trezor.messages.monero.MoneroTransactionSetInputRequest set_input = 2;
  inline bool has_set_input() const;
  inline void clear_set_input();
  static const int kSetInputFieldNumber = 2;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest& set_input() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* mutable_set_input();
  inline ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* release_set_input();
  inline void set_allocated_set_input(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* set_input);

  // optional .hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest input_permutation = 3;
  inline bool has_input_permutation() const;
  inline void clear_input_permutation();
  static const int kInputPermutationFieldNumber = 3;
  inline const ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest& input_permutation() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* mutable_input_permutation();
  inline ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* release_input_permutation();
  inline void set_allocated_input_permutation(::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* input_permutation);

  // optional .hw.trezor.messages.monero.MoneroTransactionInputViniRequest input_vini = 4;
  inline bool has_input_vini() const;
  inline void clear_input_vini();
  static const int kInputViniFieldNumber = 4;
  inline const ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest& input_vini() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* mutable_input_vini();
  inline ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* release_input_vini();
  inline void set_allocated_input_vini(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* input_vini);

  // optional .hw.trezor.messages.monero.MoneroTransactionSetOutputRequest set_output = 5;
  inline bool has_set_output() const;
  inline void clear_set_output();
  static const int kSetOutputFieldNumber = 5;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest& set_output() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* mutable_set_output();
  inline ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* release_set_output();
  inline void set_allocated_set_output(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* set_output);

  // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest all_out_set = 6;
  inline bool has_all_out_set() const;
  inline void clear_all_out_set();
  static const int kAllOutSetFieldNumber = 6;
  inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest& all_out_set() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* mutable_all_out_set();
  inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* release_all_out_set();
  inline void set_allocated_all_out_set(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* all_out_set);

  // optional .hw.trezor.messages.monero.MoneroTransactionMlsagDoneRequest mlsag_done = 7;
  inline bool has_mlsag_done() const;
  inline void clear_mlsag_done();
  static const int kMlsagDoneFieldNumber = 7;
  inline const ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest& mlsag_done() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* mutable_mlsag_done();
  inline ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* release_mlsag_done();
  inline void set_allocated_mlsag_done(::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* mlsag_done);

  // optional .hw.trezor.messages.monero.MoneroTransactionSignInputRequest sign_input = 8;
  inline bool has_sign_input() const;
  inline void clear_sign_input();
  static const int kSignInputFieldNumber = 8;
  inline const ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest& sign_input() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* mutable_sign_input();
  inline ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* release_sign_input();
  inline void set_allocated_sign_input(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* sign_input);

  // optional .hw.trezor.messages.monero.MoneroTransactionFinalRequest final_msg = 9;
  inline bool has_final_msg() const;
  inline void clear_final_msg();
  static const int kFinalMsgFieldNumber = 9;
  inline const ::hw::trezor::messages::monero::MoneroTransactionFinalRequest& final_msg() const;
  inline ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* mutable_final_msg();
  inline ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* release_final_msg();
  inline void set_allocated_final_msg(::hw::trezor::messages::monero::MoneroTransactionFinalRequest* final_msg);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroTransactionSignRequest)
 private:
  inline void set_has_init();
  inline void clear_has_init();
  inline void set_has_set_input();
  inline void clear_has_set_input();
  inline void set_has_input_permutation();
  inline void clear_has_input_permutation();
  inline void set_has_input_vini();
  inline void clear_has_input_vini();
  inline void set_has_set_output();
  inline void clear_has_set_output();
  inline void set_has_all_out_set();
  inline void clear_has_all_out_set();
  inline void set_has_mlsag_done();
  inline void clear_has_mlsag_done();
  inline void set_has_sign_input();
  inline void clear_has_sign_input();
  inline void set_has_final_msg();
  inline void clear_has_final_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest* init_;
  ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* set_input_;
  ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* input_permutation_;
  ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* input_vini_;
  ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* set_output_;
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* all_out_set_;
  ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* mlsag_done_;
  ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* sign_input_;
  ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* final_msg_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroTransactionSignRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList : public ::google::protobuf::Message {
 public:
  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList();
  virtual ~MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList();

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);

  inline MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& operator=(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& default_instance();

  void Swap(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  void MergeFrom(const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline ::google::protobuf::uint32 account() const;
  inline void set_account(::google::protobuf::uint32 value);

  // repeated uint32 minor_indices = 2;
  inline int minor_indices_size() const;
  inline void clear_minor_indices();
  static const int kMinorIndicesFieldNumber = 2;
  inline ::google::protobuf::uint32 minor_indices(int index) const;
  inline void set_minor_indices(int index, ::google::protobuf::uint32 value);
  inline void add_minor_indices(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      minor_indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_minor_indices();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > minor_indices_;
  ::google::protobuf::uint32 account_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitRequest : public ::google::protobuf::Message {
 public:
  MoneroKeyImageExportInitRequest();
  virtual ~MoneroKeyImageExportInitRequest();

  MoneroKeyImageExportInitRequest(const MoneroKeyImageExportInitRequest& from);

  inline MoneroKeyImageExportInitRequest& operator=(const MoneroKeyImageExportInitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageExportInitRequest& default_instance();

  void Swap(MoneroKeyImageExportInitRequest* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageExportInitRequest& from);
  void MergeFrom(const MoneroKeyImageExportInitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList MoneroSubAddressIndicesList;

  // accessors -------------------------------------------------------

  // optional uint64 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::uint64 num() const;
  inline void set_num(::google::protobuf::uint64 value);

  // optional bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // repeated uint32 address_n = 3;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 3;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional uint32 network_type = 4;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 network_type() const;
  inline void set_network_type(::google::protobuf::uint32 value);

  // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
  inline int subs_size() const;
  inline void clear_subs();
  static const int kSubsFieldNumber = 5;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& subs(int index) const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* mutable_subs(int index);
  inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* add_subs();
  inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
      subs() const;
  inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
      mutable_subs();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_network_type();
  inline void clear_has_network_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 num_;
  ::std::string* hash_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList > subs_;
  ::google::protobuf::uint32 network_type_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageExportInitRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageExportInitAck : public ::google::protobuf::Message {
 public:
  MoneroKeyImageExportInitAck();
  virtual ~MoneroKeyImageExportInitAck();

  MoneroKeyImageExportInitAck(const MoneroKeyImageExportInitAck& from);

  inline MoneroKeyImageExportInitAck& operator=(const MoneroKeyImageExportInitAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageExportInitAck& default_instance();

  void Swap(MoneroKeyImageExportInitAck* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageExportInitAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageExportInitAck& from);
  void MergeFrom(const MoneroKeyImageExportInitAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageExportInitAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageExportInitAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest_MoneroTransferDetails : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncStepRequest_MoneroTransferDetails();
  virtual ~MoneroKeyImageSyncStepRequest_MoneroTransferDetails();

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);

  inline MoneroKeyImageSyncStepRequest_MoneroTransferDetails& operator=(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& default_instance();

  void Swap(MoneroKeyImageSyncStepRequest_MoneroTransferDetails* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepRequest_MoneroTransferDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  void MergeFrom(const MoneroKeyImageSyncStepRequest_MoneroTransferDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes out_key = 1;
  inline bool has_out_key() const;
  inline void clear_out_key();
  static const int kOutKeyFieldNumber = 1;
  inline const ::std::string& out_key() const;
  inline void set_out_key(const ::std::string& value);
  inline void set_out_key(const char* value);
  inline void set_out_key(const void* value, size_t size);
  inline ::std::string* mutable_out_key();
  inline ::std::string* release_out_key();
  inline void set_allocated_out_key(::std::string* out_key);

  // optional bytes tx_pub_key = 2;
  inline bool has_tx_pub_key() const;
  inline void clear_tx_pub_key();
  static const int kTxPubKeyFieldNumber = 2;
  inline const ::std::string& tx_pub_key() const;
  inline void set_tx_pub_key(const ::std::string& value);
  inline void set_tx_pub_key(const char* value);
  inline void set_tx_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_tx_pub_key();
  inline ::std::string* release_tx_pub_key();
  inline void set_allocated_tx_pub_key(::std::string* tx_pub_key);

  // repeated bytes additional_tx_pub_keys = 3;
  inline int additional_tx_pub_keys_size() const;
  inline void clear_additional_tx_pub_keys();
  static const int kAdditionalTxPubKeysFieldNumber = 3;
  inline const ::std::string& additional_tx_pub_keys(int index) const;
  inline ::std::string* mutable_additional_tx_pub_keys(int index);
  inline void set_additional_tx_pub_keys(int index, const ::std::string& value);
  inline void set_additional_tx_pub_keys(int index, const char* value);
  inline void set_additional_tx_pub_keys(int index, const void* value, size_t size);
  inline ::std::string* add_additional_tx_pub_keys();
  inline void add_additional_tx_pub_keys(const ::std::string& value);
  inline void add_additional_tx_pub_keys(const char* value);
  inline void add_additional_tx_pub_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& additional_tx_pub_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_additional_tx_pub_keys();

  // optional uint64 internal_output_index = 4;
  inline bool has_internal_output_index() const;
  inline void clear_internal_output_index();
  static const int kInternalOutputIndexFieldNumber = 4;
  inline ::google::protobuf::uint64 internal_output_index() const;
  inline void set_internal_output_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails)
 private:
  inline void set_has_out_key();
  inline void clear_has_out_key();
  inline void set_has_tx_pub_key();
  inline void clear_has_tx_pub_key();
  inline void set_has_internal_output_index();
  inline void clear_has_internal_output_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* out_key_;
  ::std::string* tx_pub_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> additional_tx_pub_keys_;
  ::google::protobuf::uint64 internal_output_index_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncStepRequest_MoneroTransferDetails* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepRequest : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncStepRequest();
  virtual ~MoneroKeyImageSyncStepRequest();

  MoneroKeyImageSyncStepRequest(const MoneroKeyImageSyncStepRequest& from);

  inline MoneroKeyImageSyncStepRequest& operator=(const MoneroKeyImageSyncStepRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncStepRequest& default_instance();

  void Swap(MoneroKeyImageSyncStepRequest* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncStepRequest& from);
  void MergeFrom(const MoneroKeyImageSyncStepRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepRequest_MoneroTransferDetails MoneroTransferDetails;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
  inline int tdis_size() const;
  inline void clear_tdis();
  static const int kTdisFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& tdis(int index) const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* mutable_tdis(int index);
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* add_tdis();
  inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
      tdis() const;
  inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
      mutable_tdis();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails > tdis_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncStepRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck_MoneroExportedKeyImage : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage();
  virtual ~MoneroKeyImageSyncStepAck_MoneroExportedKeyImage();

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);

  inline MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& operator=(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& default_instance();

  void Swap(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  void MergeFrom(const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes iv = 1;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 1;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const void* value, size_t size);
  inline ::std::string* mutable_iv();
  inline ::std::string* release_iv();
  inline void set_allocated_iv(::std::string* iv);

  // optional bytes tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional bytes blob = 3;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 3;
  inline const ::std::string& blob() const;
  inline void set_blob(const ::std::string& value);
  inline void set_blob(const char* value);
  inline void set_blob(const void* value, size_t size);
  inline ::std::string* mutable_blob();
  inline ::std::string* release_blob();
  inline void set_allocated_blob(::std::string* blob);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage)
 private:
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_blob();
  inline void clear_has_blob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* iv_;
  ::std::string* tag_;
  ::std::string* blob_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncStepAck : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncStepAck();
  virtual ~MoneroKeyImageSyncStepAck();

  MoneroKeyImageSyncStepAck(const MoneroKeyImageSyncStepAck& from);

  inline MoneroKeyImageSyncStepAck& operator=(const MoneroKeyImageSyncStepAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncStepAck& default_instance();

  void Swap(MoneroKeyImageSyncStepAck* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncStepAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncStepAck& from);
  void MergeFrom(const MoneroKeyImageSyncStepAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MoneroKeyImageSyncStepAck_MoneroExportedKeyImage MoneroExportedKeyImage;

  // accessors -------------------------------------------------------

  // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
  inline int kis_size() const;
  inline void clear_kis();
  static const int kKisFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& kis(int index) const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* mutable_kis(int index);
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* add_kis();
  inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
      kis() const;
  inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
      mutable_kis();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage > kis_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncStepAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalRequest : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncFinalRequest();
  virtual ~MoneroKeyImageSyncFinalRequest();

  MoneroKeyImageSyncFinalRequest(const MoneroKeyImageSyncFinalRequest& from);

  inline MoneroKeyImageSyncFinalRequest& operator=(const MoneroKeyImageSyncFinalRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncFinalRequest& default_instance();

  void Swap(MoneroKeyImageSyncFinalRequest* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncFinalRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncFinalRequest& from);
  void MergeFrom(const MoneroKeyImageSyncFinalRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncFinalRequest* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncFinalAck : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncFinalAck();
  virtual ~MoneroKeyImageSyncFinalAck();

  MoneroKeyImageSyncFinalAck(const MoneroKeyImageSyncFinalAck& from);

  inline MoneroKeyImageSyncFinalAck& operator=(const MoneroKeyImageSyncFinalAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncFinalAck& default_instance();

  void Swap(MoneroKeyImageSyncFinalAck* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncFinalAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncFinalAck& from);
  void MergeFrom(const MoneroKeyImageSyncFinalAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes enc_key = 1;
  inline bool has_enc_key() const;
  inline void clear_enc_key();
  static const int kEncKeyFieldNumber = 1;
  inline const ::std::string& enc_key() const;
  inline void set_enc_key(const ::std::string& value);
  inline void set_enc_key(const char* value);
  inline void set_enc_key(const void* value, size_t size);
  inline ::std::string* mutable_enc_key();
  inline ::std::string* release_enc_key();
  inline void set_allocated_enc_key(::std::string* enc_key);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck)
 private:
  inline void set_has_enc_key();
  inline void clear_has_enc_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* enc_key_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncFinalAck* default_instance_;
};
// -------------------------------------------------------------------

class MoneroKeyImageSyncRequest : public ::google::protobuf::Message {
 public:
  MoneroKeyImageSyncRequest();
  virtual ~MoneroKeyImageSyncRequest();

  MoneroKeyImageSyncRequest(const MoneroKeyImageSyncRequest& from);

  inline MoneroKeyImageSyncRequest& operator=(const MoneroKeyImageSyncRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneroKeyImageSyncRequest& default_instance();

  void Swap(MoneroKeyImageSyncRequest* other);

  // implements Message ----------------------------------------------

  MoneroKeyImageSyncRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneroKeyImageSyncRequest& from);
  void MergeFrom(const MoneroKeyImageSyncRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest init = 1;
  inline bool has_init() const;
  inline void clear_init();
  static const int kInitFieldNumber = 1;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest& init() const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* mutable_init();
  inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* release_init();
  inline void set_allocated_init(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* init);

  // optional .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest step = 2;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 2;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest& step() const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* mutable_step();
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* release_step();
  inline void set_allocated_step(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* step);

  // optional .hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest final_msg = 3;
  inline bool has_final_msg() const;
  inline void clear_final_msg();
  static const int kFinalMsgFieldNumber = 3;
  inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest& final_msg() const;
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* mutable_final_msg();
  inline ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* release_final_msg();
  inline void set_allocated_final_msg(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* final_msg);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.MoneroKeyImageSyncRequest)
 private:
  inline void set_has_init();
  inline void clear_has_init();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_final_msg();
  inline void clear_has_final_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* init_;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* step_;
  ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* final_msg_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static MoneroKeyImageSyncRequest* default_instance_;
};
// -------------------------------------------------------------------

class DebugMoneroDiagRequest : public ::google::protobuf::Message {
 public:
  DebugMoneroDiagRequest();
  virtual ~DebugMoneroDiagRequest();

  DebugMoneroDiagRequest(const DebugMoneroDiagRequest& from);

  inline DebugMoneroDiagRequest& operator=(const DebugMoneroDiagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugMoneroDiagRequest& default_instance();

  void Swap(DebugMoneroDiagRequest* other);

  // implements Message ----------------------------------------------

  DebugMoneroDiagRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugMoneroDiagRequest& from);
  void MergeFrom(const DebugMoneroDiagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ins = 1;
  inline bool has_ins() const;
  inline void clear_ins();
  static const int kInsFieldNumber = 1;
  inline ::google::protobuf::uint64 ins() const;
  inline void set_ins(::google::protobuf::uint64 value);

  // optional uint64 p1 = 2;
  inline bool has_p1() const;
  inline void clear_p1();
  static const int kP1FieldNumber = 2;
  inline ::google::protobuf::uint64 p1() const;
  inline void set_p1(::google::protobuf::uint64 value);

  // optional uint64 p2 = 3;
  inline bool has_p2() const;
  inline void clear_p2();
  static const int kP2FieldNumber = 3;
  inline ::google::protobuf::uint64 p2() const;
  inline void set_p2(::google::protobuf::uint64 value);

  // repeated uint64 pd = 4;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 4;
  inline ::google::protobuf::uint64 pd(int index) const;
  inline void set_pd(int index, ::google::protobuf::uint64 value);
  inline void add_pd(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pd() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pd();

  // optional bytes data1 = 5;
  inline bool has_data1() const;
  inline void clear_data1();
  static const int kData1FieldNumber = 5;
  inline const ::std::string& data1() const;
  inline void set_data1(const ::std::string& value);
  inline void set_data1(const char* value);
  inline void set_data1(const void* value, size_t size);
  inline ::std::string* mutable_data1();
  inline ::std::string* release_data1();
  inline void set_allocated_data1(::std::string* data1);

  // optional bytes data2 = 6;
  inline bool has_data2() const;
  inline void clear_data2();
  static const int kData2FieldNumber = 6;
  inline const ::std::string& data2() const;
  inline void set_data2(const ::std::string& value);
  inline void set_data2(const char* value);
  inline void set_data2(const void* value, size_t size);
  inline ::std::string* mutable_data2();
  inline ::std::string* release_data2();
  inline void set_allocated_data2(::std::string* data2);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagRequest)
 private:
  inline void set_has_ins();
  inline void clear_has_ins();
  inline void set_has_p1();
  inline void clear_has_p1();
  inline void set_has_p2();
  inline void clear_has_p2();
  inline void set_has_data1();
  inline void clear_has_data1();
  inline void set_has_data2();
  inline void clear_has_data2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 ins_;
  ::google::protobuf::uint64 p1_;
  ::google::protobuf::uint64 p2_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pd_;
  ::std::string* data1_;
  ::std::string* data2_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static DebugMoneroDiagRequest* default_instance_;
};
// -------------------------------------------------------------------

class DebugMoneroDiagAck : public ::google::protobuf::Message {
 public:
  DebugMoneroDiagAck();
  virtual ~DebugMoneroDiagAck();

  DebugMoneroDiagAck(const DebugMoneroDiagAck& from);

  inline DebugMoneroDiagAck& operator=(const DebugMoneroDiagAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugMoneroDiagAck& default_instance();

  void Swap(DebugMoneroDiagAck* other);

  // implements Message ----------------------------------------------

  DebugMoneroDiagAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugMoneroDiagAck& from);
  void MergeFrom(const DebugMoneroDiagAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ins = 1;
  inline bool has_ins() const;
  inline void clear_ins();
  static const int kInsFieldNumber = 1;
  inline ::google::protobuf::uint64 ins() const;
  inline void set_ins(::google::protobuf::uint64 value);

  // optional uint64 p1 = 2;
  inline bool has_p1() const;
  inline void clear_p1();
  static const int kP1FieldNumber = 2;
  inline ::google::protobuf::uint64 p1() const;
  inline void set_p1(::google::protobuf::uint64 value);

  // optional uint64 p2 = 3;
  inline bool has_p2() const;
  inline void clear_p2();
  static const int kP2FieldNumber = 3;
  inline ::google::protobuf::uint64 p2() const;
  inline void set_p2(::google::protobuf::uint64 value);

  // repeated uint64 pd = 4;
  inline int pd_size() const;
  inline void clear_pd();
  static const int kPdFieldNumber = 4;
  inline ::google::protobuf::uint64 pd(int index) const;
  inline void set_pd(int index, ::google::protobuf::uint64 value);
  inline void add_pd(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pd() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pd();

  // optional bytes data1 = 5;
  inline bool has_data1() const;
  inline void clear_data1();
  static const int kData1FieldNumber = 5;
  inline const ::std::string& data1() const;
  inline void set_data1(const ::std::string& value);
  inline void set_data1(const char* value);
  inline void set_data1(const void* value, size_t size);
  inline ::std::string* mutable_data1();
  inline ::std::string* release_data1();
  inline void set_allocated_data1(::std::string* data1);

  // optional bytes data2 = 6;
  inline bool has_data2() const;
  inline void clear_data2();
  static const int kData2FieldNumber = 6;
  inline const ::std::string& data2() const;
  inline void set_data2(const ::std::string& value);
  inline void set_data2(const char* value);
  inline void set_data2(const void* value, size_t size);
  inline ::std::string* mutable_data2();
  inline ::std::string* release_data2();
  inline void set_allocated_data2(::std::string* data2);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.monero.DebugMoneroDiagAck)
 private:
  inline void set_has_ins();
  inline void clear_has_ins();
  inline void set_has_p1();
  inline void clear_has_p1();
  inline void set_has_p2();
  inline void clear_has_p2();
  inline void set_has_data1();
  inline void clear_has_data1();
  inline void set_has_data2();
  inline void clear_has_data2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 ins_;
  ::google::protobuf::uint64 p1_;
  ::google::protobuf::uint64 p2_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pd_;
  ::std::string* data1_;
  ::std::string* data2_;
  friend void  protobuf_AddDesc_messages_2dmonero_2eproto();
  friend void protobuf_AssignDesc_messages_2dmonero_2eproto();
  friend void protobuf_ShutdownFile_messages_2dmonero_2eproto();

  void InitAsDefaultInstance();
  static DebugMoneroDiagAck* default_instance_;
};
// ===================================================================


// ===================================================================

// MoneroGetAddress

// repeated uint32 address_n = 1;
inline int MoneroGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void MoneroGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return address_n_.Get(index);
}
inline void MoneroGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline void MoneroGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool MoneroGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroGetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroGetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroGetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool MoneroGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.show_display)
  return show_display_;
}
inline void MoneroGetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.show_display)
}

// optional uint32 network_type = 3;
inline bool MoneroGetAddress::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroGetAddress::set_has_network_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroGetAddress::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroGetAddress::clear_network_type() {
  network_type_ = 0u;
  clear_has_network_type();
}
inline ::google::protobuf::uint32 MoneroGetAddress::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.network_type)
  return network_type_;
}
inline void MoneroGetAddress::set_network_type(::google::protobuf::uint32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.network_type)
}

// optional uint32 account = 4;
inline bool MoneroGetAddress::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroGetAddress::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroGetAddress::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroGetAddress::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 MoneroGetAddress::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.account)
  return account_;
}
inline void MoneroGetAddress::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.account)
}

// optional uint32 minor = 5;
inline bool MoneroGetAddress::has_minor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroGetAddress::set_has_minor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroGetAddress::clear_has_minor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroGetAddress::clear_minor() {
  minor_ = 0u;
  clear_has_minor();
}
inline ::google::protobuf::uint32 MoneroGetAddress::minor() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetAddress.minor)
  return minor_;
}
inline void MoneroGetAddress::set_minor(::google::protobuf::uint32 value) {
  set_has_minor();
  minor_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetAddress.minor)
}

// -------------------------------------------------------------------

// MoneroAddress

// optional bytes address = 1;
inline bool MoneroAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroAddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroAddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroAddress::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& MoneroAddress::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroAddress.address)
  return *address_;
}
inline void MoneroAddress::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroAddress.address)
}
inline void MoneroAddress::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroAddress.address)
}
inline void MoneroAddress::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroAddress.address)
}
inline ::std::string* MoneroAddress::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroAddress.address)
  return address_;
}
inline ::std::string* MoneroAddress::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroAddress::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroAddress.address)
}

// -------------------------------------------------------------------

// MoneroGetWatchKey

// repeated uint32 address_n = 1;
inline int MoneroGetWatchKey::address_n_size() const {
  return address_n_.size();
}
inline void MoneroGetWatchKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroGetWatchKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return address_n_.Get(index);
}
inline void MoneroGetWatchKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline void MoneroGetWatchKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroGetWatchKey::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroGetWatchKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroGetWatchKey.address_n)
  return &address_n_;
}

// optional uint32 network_type = 2;
inline bool MoneroGetWatchKey::has_network_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroGetWatchKey::set_has_network_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroGetWatchKey::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroGetWatchKey::clear_network_type() {
  network_type_ = 0u;
  clear_has_network_type();
}
inline ::google::protobuf::uint32 MoneroGetWatchKey::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
  return network_type_;
}
inline void MoneroGetWatchKey::set_network_type(::google::protobuf::uint32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroGetWatchKey.network_type)
}

// -------------------------------------------------------------------

// MoneroWatchKey

// optional bytes watch_key = 1;
inline bool MoneroWatchKey::has_watch_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroWatchKey::set_has_watch_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroWatchKey::clear_has_watch_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroWatchKey::clear_watch_key() {
  if (watch_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    watch_key_->clear();
  }
  clear_has_watch_key();
}
inline const ::std::string& MoneroWatchKey::watch_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return *watch_key_;
}
inline void MoneroWatchKey::set_watch_key(const ::std::string& value) {
  set_has_watch_key();
  if (watch_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    watch_key_ = new ::std::string;
  }
  watch_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline void MoneroWatchKey::set_watch_key(const char* value) {
  set_has_watch_key();
  if (watch_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    watch_key_ = new ::std::string;
  }
  watch_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline void MoneroWatchKey::set_watch_key(const void* value, size_t size) {
  set_has_watch_key();
  if (watch_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    watch_key_ = new ::std::string;
  }
  watch_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}
inline ::std::string* MoneroWatchKey::mutable_watch_key() {
  set_has_watch_key();
  if (watch_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    watch_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
  return watch_key_;
}
inline ::std::string* MoneroWatchKey::release_watch_key() {
  clear_has_watch_key();
  if (watch_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = watch_key_;
    watch_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroWatchKey::set_allocated_watch_key(::std::string* watch_key) {
  if (watch_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete watch_key_;
  }
  if (watch_key) {
    set_has_watch_key();
    watch_key_ = watch_key;
  } else {
    clear_has_watch_key();
    watch_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.watch_key)
}

// optional bytes address = 2;
inline bool MoneroWatchKey::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroWatchKey::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroWatchKey::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroWatchKey::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& MoneroWatchKey::address() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroWatchKey.address)
  return *address_;
}
inline void MoneroWatchKey::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline void MoneroWatchKey::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline void MoneroWatchKey::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroWatchKey.address)
}
inline ::std::string* MoneroWatchKey::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroWatchKey.address)
  return address_;
}
inline ::std::string* MoneroWatchKey::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroWatchKey::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroWatchKey.address)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry_MoneroAccountPublicAddress

// optional bytes spend_public_key = 1;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_spend_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_has_spend_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_has_spend_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_spend_public_key() {
  if (spend_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_public_key_->clear();
  }
  clear_has_spend_public_key();
}
inline const ::std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::spend_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return *spend_public_key_;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const ::std::string& value) {
  set_has_spend_public_key();
  if (spend_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_public_key_ = new ::std::string;
  }
  spend_public_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const char* value) {
  set_has_spend_public_key();
  if (spend_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_public_key_ = new ::std::string;
  }
  spend_public_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_spend_public_key(const void* value, size_t size) {
  set_has_spend_public_key();
  if (spend_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_public_key_ = new ::std::string;
  }
  spend_public_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_spend_public_key() {
  set_has_spend_public_key();
  if (spend_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_public_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
  return spend_public_key_;
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_spend_public_key() {
  clear_has_spend_public_key();
  if (spend_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = spend_public_key_;
    spend_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_spend_public_key(::std::string* spend_public_key) {
  if (spend_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete spend_public_key_;
  }
  if (spend_public_key) {
    set_has_spend_public_key();
    spend_public_key_ = spend_public_key;
  } else {
    clear_has_spend_public_key();
    spend_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.spend_public_key)
}

// optional bytes view_public_key = 2;
inline bool MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::has_view_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_has_view_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_has_view_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::clear_view_public_key() {
  if (view_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    view_public_key_->clear();
  }
  clear_has_view_public_key();
}
inline const ::std::string& MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return *view_public_key_;
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const ::std::string& value) {
  set_has_view_public_key();
  if (view_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    view_public_key_ = new ::std::string;
  }
  view_public_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const char* value) {
  set_has_view_public_key();
  if (view_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    view_public_key_ = new ::std::string;
  }
  view_public_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_view_public_key(const void* value, size_t size) {
  set_has_view_public_key();
  if (view_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    view_public_key_ = new ::std::string;
  }
  view_public_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::mutable_view_public_key() {
  set_has_view_public_key();
  if (view_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    view_public_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
  return view_public_key_;
}
inline ::std::string* MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::release_view_public_key() {
  clear_has_view_public_key();
  if (view_public_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = view_public_key_;
    view_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::set_allocated_view_public_key(::std::string* view_public_key) {
  if (view_public_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete view_public_key_;
  }
  if (view_public_key) {
    set_has_view_public_key();
    view_public_key_ = view_public_key;
  } else {
    clear_has_view_public_key();
    view_public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress.view_public_key)
}

// -------------------------------------------------------------------

// MoneroTransactionDestinationEntry

// optional uint64 amount = 1;
inline bool MoneroTransactionDestinationEntry::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionDestinationEntry::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionDestinationEntry::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionDestinationEntry::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 MoneroTransactionDestinationEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
  return amount_;
}
inline void MoneroTransactionDestinationEntry::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.amount)
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;
inline bool MoneroTransactionDestinationEntry::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionDestinationEntry::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionDestinationEntry::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionDestinationEntry::clear_addr() {
  if (addr_ != NULL) addr_->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::Clear();
  clear_has_addr();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress& MoneroTransactionDestinationEntry::addr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return addr_ != NULL ? *addr_ : *default_instance_->addr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::mutable_addr() {
  set_has_addr();
  if (addr_ == NULL) addr_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
  return addr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* MoneroTransactionDestinationEntry::release_addr() {
  clear_has_addr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* temp = addr_;
  addr_ = NULL;
  return temp;
}
inline void MoneroTransactionDestinationEntry::set_allocated_addr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry_MoneroAccountPublicAddress* addr) {
  delete addr_;
  addr_ = addr;
  if (addr) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.addr)
}

// optional bool is_subaddress = 3;
inline bool MoneroTransactionDestinationEntry::has_is_subaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionDestinationEntry::set_has_is_subaddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionDestinationEntry::clear_has_is_subaddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionDestinationEntry::clear_is_subaddress() {
  is_subaddress_ = false;
  clear_has_is_subaddress();
}
inline bool MoneroTransactionDestinationEntry::is_subaddress() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
  return is_subaddress_;
}
inline void MoneroTransactionDestinationEntry::set_is_subaddress(bool value) {
  set_has_is_subaddress();
  is_subaddress_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionDestinationEntry.is_subaddress)
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest_MoneroTransactionData

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
  return version_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.version)
}

// optional bytes payment_id = 2;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_payment_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_payment_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_payment_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_payment_id() {
  if (payment_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payment_id_->clear();
  }
  clear_has_payment_id();
}
inline const ::std::string& MoneroTransactionInitRequest_MoneroTransactionData::payment_id() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return *payment_id_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const ::std::string& value) {
  set_has_payment_id();
  if (payment_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payment_id_ = new ::std::string;
  }
  payment_id_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const char* value) {
  set_has_payment_id();
  if (payment_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payment_id_ = new ::std::string;
  }
  payment_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_payment_id(const void* value, size_t size) {
  set_has_payment_id();
  if (payment_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payment_id_ = new ::std::string;
  }
  payment_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_payment_id() {
  set_has_payment_id();
  if (payment_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payment_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
  return payment_id_;
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::release_payment_id() {
  clear_has_payment_id();
  if (payment_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payment_id_;
    payment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_payment_id(::std::string* payment_id) {
  if (payment_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payment_id_;
  }
  if (payment_id) {
    set_has_payment_id();
    payment_id_ = payment_id;
  } else {
    clear_has_payment_id();
    payment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.payment_id)
}

// optional uint64 unlock_time = 3;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_unlock_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_unlock_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_unlock_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_unlock_time() {
  unlock_time_ = GOOGLE_ULONGLONG(0);
  clear_has_unlock_time();
}
inline ::google::protobuf::uint64 MoneroTransactionInitRequest_MoneroTransactionData::unlock_time() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
  return unlock_time_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_unlock_time(::google::protobuf::uint64 value) {
  set_has_unlock_time();
  unlock_time_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.unlock_time)
}

// repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;
inline int MoneroTransactionInitRequest_MoneroTransactionData::outputs_size() const {
  return outputs_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_outputs() {
  outputs_.Clear();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Mutable(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >&
MoneroTransactionInitRequest_MoneroTransactionData::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.outputs)
  return &outputs_;
}

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_change_dts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_change_dts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_change_dts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_change_dts() {
  if (change_dts_ != NULL) change_dts_->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry::Clear();
  clear_has_change_dts();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionInitRequest_MoneroTransactionData::change_dts() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return change_dts_ != NULL ? *change_dts_ : *default_instance_->change_dts_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::mutable_change_dts() {
  set_has_change_dts();
  if (change_dts_ == NULL) change_dts_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
  return change_dts_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionInitRequest_MoneroTransactionData::release_change_dts() {
  clear_has_change_dts();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = change_dts_;
  change_dts_ = NULL;
  return temp;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_change_dts(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* change_dts) {
  delete change_dts_;
  change_dts_ = change_dts;
  if (change_dts) {
    set_has_change_dts();
  } else {
    clear_has_change_dts();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.change_dts)
}

// optional uint32 num_inputs = 6;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_num_inputs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_num_inputs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_num_inputs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_num_inputs() {
  num_inputs_ = 0u;
  clear_has_num_inputs();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::num_inputs() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
  return num_inputs_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_num_inputs(::google::protobuf::uint32 value) {
  set_has_num_inputs();
  num_inputs_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.num_inputs)
}

// optional uint32 mixin = 7;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_mixin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_mixin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_mixin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_mixin() {
  mixin_ = 0u;
  clear_has_mixin();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::mixin() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
  return mixin_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_mixin(::google::protobuf::uint32 value) {
  set_has_mixin();
  mixin_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.mixin)
}

// optional uint64 fee = 8;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_fee() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_fee() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_fee() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_fee() {
  fee_ = GOOGLE_ULONGLONG(0);
  clear_has_fee();
}
inline ::google::protobuf::uint64 MoneroTransactionInitRequest_MoneroTransactionData::fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
  return fee_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_fee(::google::protobuf::uint64 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.fee)
}

// optional uint32 account = 9;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_account() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_account() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_account() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
  return account_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.account)
}

// repeated uint32 minor_indices = 10;
inline int MoneroTransactionInitRequest_MoneroTransactionData::minor_indices_size() const {
  return minor_indices_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_minor_indices() {
  minor_indices_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest_MoneroTransactionData::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return minor_indices_.Get(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_minor_indices(int index, ::google::protobuf::uint32 value) {
  minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_minor_indices(::google::protobuf::uint32 value) {
  minor_indices_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInitRequest_MoneroTransactionData::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return minor_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.minor_indices)
  return &minor_indices_;
}

// optional bool is_multisig = 11;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_is_multisig() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_is_multisig() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_is_multisig() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_is_multisig() {
  is_multisig_ = false;
  clear_has_is_multisig();
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::is_multisig() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.is_multisig)
  return is_multisig_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_is_multisig(bool value) {
  set_has_is_multisig();
  is_multisig_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.is_multisig)
}

// optional bytes exp_tx_prefix_hash = 12;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_exp_tx_prefix_hash() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_exp_tx_prefix_hash() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_exp_tx_prefix_hash() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_exp_tx_prefix_hash() {
  if (exp_tx_prefix_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exp_tx_prefix_hash_->clear();
  }
  clear_has_exp_tx_prefix_hash();
}
inline const ::std::string& MoneroTransactionInitRequest_MoneroTransactionData::exp_tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
  return *exp_tx_prefix_hash_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_exp_tx_prefix_hash(const ::std::string& value) {
  set_has_exp_tx_prefix_hash();
  if (exp_tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exp_tx_prefix_hash_ = new ::std::string;
  }
  exp_tx_prefix_hash_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_exp_tx_prefix_hash(const char* value) {
  set_has_exp_tx_prefix_hash();
  if (exp_tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exp_tx_prefix_hash_ = new ::std::string;
  }
  exp_tx_prefix_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_exp_tx_prefix_hash(const void* value, size_t size) {
  set_has_exp_tx_prefix_hash();
  if (exp_tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exp_tx_prefix_hash_ = new ::std::string;
  }
  exp_tx_prefix_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_exp_tx_prefix_hash() {
  set_has_exp_tx_prefix_hash();
  if (exp_tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exp_tx_prefix_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
  return exp_tx_prefix_hash_;
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::release_exp_tx_prefix_hash() {
  clear_has_exp_tx_prefix_hash();
  if (exp_tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exp_tx_prefix_hash_;
    exp_tx_prefix_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_allocated_exp_tx_prefix_hash(::std::string* exp_tx_prefix_hash) {
  if (exp_tx_prefix_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exp_tx_prefix_hash_;
  }
  if (exp_tx_prefix_hash) {
    set_has_exp_tx_prefix_hash();
    exp_tx_prefix_hash_ = exp_tx_prefix_hash;
  } else {
    clear_has_exp_tx_prefix_hash();
    exp_tx_prefix_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.exp_tx_prefix_hash)
}

// repeated bytes use_tx_keys = 13;
inline int MoneroTransactionInitRequest_MoneroTransactionData::use_tx_keys_size() const {
  return use_tx_keys_.size();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_use_tx_keys() {
  use_tx_keys_.Clear();
}
inline const ::std::string& MoneroTransactionInitRequest_MoneroTransactionData::use_tx_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
  return use_tx_keys_.Get(index);
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::mutable_use_tx_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
  return use_tx_keys_.Mutable(index);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_use_tx_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
  use_tx_keys_.Mutable(index)->assign(value);
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_use_tx_keys(int index, const char* value) {
  use_tx_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_use_tx_keys(int index, const void* value, size_t size) {
  use_tx_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
}
inline ::std::string* MoneroTransactionInitRequest_MoneroTransactionData::add_use_tx_keys() {
  return use_tx_keys_.Add();
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_use_tx_keys(const ::std::string& value) {
  use_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_use_tx_keys(const char* value) {
  use_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::add_use_tx_keys(const void* value, size_t size) {
  use_tx_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MoneroTransactionInitRequest_MoneroTransactionData::use_tx_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
  return use_tx_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MoneroTransactionInitRequest_MoneroTransactionData::mutable_use_tx_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.use_tx_keys)
  return &use_tx_keys_;
}

// optional bool is_bulletproof = 14;
inline bool MoneroTransactionInitRequest_MoneroTransactionData::has_is_bulletproof() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_has_is_bulletproof() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_has_is_bulletproof() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::clear_is_bulletproof() {
  is_bulletproof_ = false;
  clear_has_is_bulletproof();
}
inline bool MoneroTransactionInitRequest_MoneroTransactionData::is_bulletproof() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.is_bulletproof)
  return is_bulletproof_;
}
inline void MoneroTransactionInitRequest_MoneroTransactionData::set_is_bulletproof(bool value) {
  set_has_is_bulletproof();
  is_bulletproof_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData.is_bulletproof)
}

// -------------------------------------------------------------------

// MoneroTransactionInitRequest

// optional uint32 version = 1;
inline bool MoneroTransactionInitRequest::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitRequest::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionInitRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionInitRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
  return version_;
}
inline void MoneroTransactionInitRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.version)
}

// repeated uint32 address_n = 2;
inline int MoneroTransactionInitRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroTransactionInitRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroTransactionInitRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline void MoneroTransactionInitRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 3;
inline bool MoneroTransactionInitRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInitRequest::set_has_network_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionInitRequest::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionInitRequest::clear_network_type() {
  network_type_ = 0u;
  clear_has_network_type();
}
inline ::google::protobuf::uint32 MoneroTransactionInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
  return network_type_;
}
inline void MoneroTransactionInitRequest::set_network_type(::google::protobuf::uint32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitRequest.network_type)
}

// optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;
inline bool MoneroTransactionInitRequest::has_tsx_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionInitRequest::set_has_tsx_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionInitRequest::clear_has_tsx_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionInitRequest::clear_tsx_data() {
  if (tsx_data_ != NULL) tsx_data_->::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData::Clear();
  clear_has_tsx_data();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData& MoneroTransactionInitRequest::tsx_data() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return tsx_data_ != NULL ? *tsx_data_ : *default_instance_->tsx_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::mutable_tsx_data() {
  set_has_tsx_data();
  if (tsx_data_ == NULL) tsx_data_ = new ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
  return tsx_data_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* MoneroTransactionInitRequest::release_tsx_data() {
  clear_has_tsx_data();
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* temp = tsx_data_;
  tsx_data_ = NULL;
  return temp;
}
inline void MoneroTransactionInitRequest::set_allocated_tsx_data(::hw::trezor::messages::monero::MoneroTransactionInitRequest_MoneroTransactionData* tsx_data) {
  delete tsx_data_;
  tsx_data_ = tsx_data;
  if (tsx_data) {
    set_has_tsx_data();
  } else {
    clear_has_tsx_data();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInitRequest.tsx_data)
}

// -------------------------------------------------------------------

// MoneroTransactionInitAck

// optional uint32 version = 1;
inline bool MoneroTransactionInitAck::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInitAck::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionInitAck::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionInitAck::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MoneroTransactionInitAck::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.version)
  return version_;
}
inline void MoneroTransactionInitAck::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.version)
}

// optional uint32 status = 2;
inline bool MoneroTransactionInitAck::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInitAck::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionInitAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionInitAck::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MoneroTransactionInitAck::status() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.status)
  return status_;
}
inline void MoneroTransactionInitAck::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.status)
}

// optional bool in_memory = 3;
inline bool MoneroTransactionInitAck::has_in_memory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInitAck::set_has_in_memory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionInitAck::clear_has_in_memory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionInitAck::clear_in_memory() {
  in_memory_ = false;
  clear_has_in_memory();
}
inline bool MoneroTransactionInitAck::in_memory() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.in_memory)
  return in_memory_;
}
inline void MoneroTransactionInitAck::set_in_memory(bool value) {
  set_has_in_memory();
  in_memory_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.in_memory)
}

// repeated bytes hmacs = 4;
inline int MoneroTransactionInitAck::hmacs_size() const {
  return hmacs_.size();
}
inline void MoneroTransactionInitAck::clear_hmacs() {
  hmacs_.Clear();
}
inline const ::std::string& MoneroTransactionInitAck::hmacs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_.Get(index);
}
inline ::std::string* MoneroTransactionInitAck::mutable_hmacs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_.Mutable(index);
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  hmacs_.Mutable(index)->assign(value);
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const char* value) {
  hmacs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::set_hmacs(int index, const void* value, size_t size) {
  hmacs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline ::std::string* MoneroTransactionInitAck::add_hmacs() {
  return hmacs_.Add();
}
inline void MoneroTransactionInitAck::add_hmacs(const ::std::string& value) {
  hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(const char* value) {
  hmacs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline void MoneroTransactionInitAck::add_hmacs(const void* value, size_t size) {
  hmacs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MoneroTransactionInitAck::hmacs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return hmacs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MoneroTransactionInitAck::mutable_hmacs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInitAck.hmacs)
  return &hmacs_;
}

// optional bool many_inputs = 5;
inline bool MoneroTransactionInitAck::has_many_inputs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionInitAck::set_has_many_inputs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionInitAck::clear_has_many_inputs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionInitAck::clear_many_inputs() {
  many_inputs_ = false;
  clear_has_many_inputs();
}
inline bool MoneroTransactionInitAck::many_inputs() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.many_inputs)
  return many_inputs_;
}
inline void MoneroTransactionInitAck::set_many_inputs(bool value) {
  set_has_many_inputs();
  many_inputs_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.many_inputs)
}

// optional bool many_outputs = 6;
inline bool MoneroTransactionInitAck::has_many_outputs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionInitAck::set_has_many_outputs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionInitAck::clear_has_many_outputs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionInitAck::clear_many_outputs() {
  many_outputs_ = false;
  clear_has_many_outputs();
}
inline bool MoneroTransactionInitAck::many_outputs() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInitAck.many_outputs)
  return many_outputs_;
}
inline void MoneroTransactionInitAck::set_many_outputs(bool value) {
  set_has_many_outputs();
  many_outputs_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInitAck.many_outputs)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroRctKey

// optional bytes dest = 1;
inline bool MoneroTransactionSourceEntry_MoneroRctKey::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::clear_dest() {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroRctKey::dest() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
  return *dest_;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_dest(const void* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroRctKey::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
  return dest_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroRctKey::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.dest)
}

// optional bytes mask = 2;
inline bool MoneroTransactionSourceEntry_MoneroRctKey::has_mask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_has_mask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::clear_has_mask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::clear_mask() {
  if (mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_->clear();
  }
  clear_has_mask();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroRctKey::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
  return *mask_;
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_mask(const ::std::string& value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_mask(const char* value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_mask(const void* value, size_t size) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroRctKey::mutable_mask() {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
  return mask_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroRctKey::release_mask() {
  clear_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mask_;
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroRctKey::set_allocated_mask(::std::string* mask) {
  if (mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mask_;
  }
  if (mask) {
    set_has_mask();
    mask_ = mask;
  } else {
    clear_has_mask();
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey.mask)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroOutputEntry

// optional uint64 amount = 1;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry_MoneroOutputEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.amount)
  return amount_;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.amount)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroRctKey key = 2;
inline bool MoneroTransactionSourceEntry_MoneroOutputEntry::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::clear_key() {
  if (key_ != NULL) key_->::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey::Clear();
  clear_has_key();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey& MoneroTransactionSourceEntry_MoneroOutputEntry::key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* MoneroTransactionSourceEntry_MoneroOutputEntry::mutable_key() {
  set_has_key();
  if (key_ == NULL) key_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
  return key_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* MoneroTransactionSourceEntry_MoneroOutputEntry::release_key() {
  clear_has_key();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void MoneroTransactionSourceEntry_MoneroOutputEntry::set_allocated_key(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroRctKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.key)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry_MoneroMultisigKLRki

// optional bytes K = 1;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_k() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_has_k() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_has_k() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_k() {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_->clear();
  }
  clear_has_k();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::k() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return *k_;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const ::std::string& value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const char* value) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_k(const void* value, size_t size) {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  k_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_k() {
  set_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    k_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
  return k_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_k() {
  clear_has_k();
  if (k_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = k_;
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_k(::std::string* k) {
  if (k_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete k_;
  }
  if (k) {
    set_has_k();
    k_ = k;
  } else {
    clear_has_k();
    k_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.K)
}

// optional bytes L = 2;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_l() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_has_l() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_has_l() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_l() {
  if (l_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_->clear();
  }
  clear_has_l();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::l() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return *l_;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const ::std::string& value) {
  set_has_l();
  if (l_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_ = new ::std::string;
  }
  l_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const char* value) {
  set_has_l();
  if (l_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_ = new ::std::string;
  }
  l_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_l(const void* value, size_t size) {
  set_has_l();
  if (l_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_ = new ::std::string;
  }
  l_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_l() {
  set_has_l();
  if (l_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    l_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
  return l_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_l() {
  clear_has_l();
  if (l_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = l_;
    l_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_l(::std::string* l) {
  if (l_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete l_;
  }
  if (l) {
    set_has_l();
    l_ = l;
  } else {
    clear_has_l();
    l_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.L)
}

// optional bytes R = 3;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_r() {
  if (r_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    r_->clear();
  }
  clear_has_r();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::r() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return *r_;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const ::std::string& value) {
  set_has_r();
  if (r_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    r_ = new ::std::string;
  }
  r_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const char* value) {
  set_has_r();
  if (r_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    r_ = new ::std::string;
  }
  r_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_r(const void* value, size_t size) {
  set_has_r();
  if (r_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    r_ = new ::std::string;
  }
  r_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_r() {
  set_has_r();
  if (r_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    r_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
  return r_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_r() {
  clear_has_r();
  if (r_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = r_;
    r_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_r(::std::string* r) {
  if (r_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete r_;
  }
  if (r) {
    set_has_r();
    r_ = r;
  } else {
    clear_has_r();
    r_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.R)
}

// optional bytes ki = 4;
inline bool MoneroTransactionSourceEntry_MoneroMultisigKLRki::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::clear_ki() {
  if (ki_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ki_->clear();
  }
  clear_has_ki();
}
inline const ::std::string& MoneroTransactionSourceEntry_MoneroMultisigKLRki::ki() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return *ki_;
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const ::std::string& value) {
  set_has_ki();
  if (ki_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ki_ = new ::std::string;
  }
  ki_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const char* value) {
  set_has_ki();
  if (ki_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ki_ = new ::std::string;
  }
  ki_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_ki(const void* value, size_t size) {
  set_has_ki();
  if (ki_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ki_ = new ::std::string;
  }
  ki_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::mutable_ki() {
  set_has_ki();
  if (ki_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ki_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
  return ki_;
}
inline ::std::string* MoneroTransactionSourceEntry_MoneroMultisigKLRki::release_ki() {
  clear_has_ki();
  if (ki_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ki_;
    ki_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry_MoneroMultisigKLRki::set_allocated_ki(::std::string* ki) {
  if (ki_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ki_;
  }
  if (ki) {
    set_has_ki();
    ki_ = ki;
  } else {
    clear_has_ki();
    ki_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki.ki)
}

// -------------------------------------------------------------------

// MoneroTransactionSourceEntry

// repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;
inline int MoneroTransactionSourceEntry::outputs_size() const {
  return outputs_.size();
}
inline void MoneroTransactionSourceEntry::clear_outputs() {
  outputs_.Clear();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry& MoneroTransactionSourceEntry::outputs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Mutable(index);
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry* MoneroTransactionSourceEntry::add_outputs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >&
MoneroTransactionSourceEntry::outputs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroOutputEntry >*
MoneroTransactionSourceEntry::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.outputs)
  return &outputs_;
}

// optional uint64 real_output = 2;
inline bool MoneroTransactionSourceEntry::has_real_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_real_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSourceEntry::clear_has_real_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSourceEntry::clear_real_output() {
  real_output_ = GOOGLE_ULONGLONG(0);
  clear_has_real_output();
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::real_output() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
  return real_output_;
}
inline void MoneroTransactionSourceEntry::set_real_output(::google::protobuf::uint64 value) {
  set_has_real_output();
  real_output_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output)
}

// optional bytes real_out_tx_key = 3;
inline bool MoneroTransactionSourceEntry::has_real_out_tx_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_real_out_tx_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSourceEntry::clear_has_real_out_tx_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSourceEntry::clear_real_out_tx_key() {
  if (real_out_tx_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_out_tx_key_->clear();
  }
  clear_has_real_out_tx_key();
}
inline const ::std::string& MoneroTransactionSourceEntry::real_out_tx_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return *real_out_tx_key_;
}
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const ::std::string& value) {
  set_has_real_out_tx_key();
  if (real_out_tx_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_out_tx_key_ = new ::std::string;
  }
  real_out_tx_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const char* value) {
  set_has_real_out_tx_key();
  if (real_out_tx_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_out_tx_key_ = new ::std::string;
  }
  real_out_tx_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline void MoneroTransactionSourceEntry::set_real_out_tx_key(const void* value, size_t size) {
  set_has_real_out_tx_key();
  if (real_out_tx_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_out_tx_key_ = new ::std::string;
  }
  real_out_tx_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_real_out_tx_key() {
  set_has_real_out_tx_key();
  if (real_out_tx_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    real_out_tx_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
  return real_out_tx_key_;
}
inline ::std::string* MoneroTransactionSourceEntry::release_real_out_tx_key() {
  clear_has_real_out_tx_key();
  if (real_out_tx_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = real_out_tx_key_;
    real_out_tx_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry::set_allocated_real_out_tx_key(::std::string* real_out_tx_key) {
  if (real_out_tx_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete real_out_tx_key_;
  }
  if (real_out_tx_key) {
    set_has_real_out_tx_key();
    real_out_tx_key_ = real_out_tx_key;
  } else {
    clear_has_real_out_tx_key();
    real_out_tx_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_tx_key)
}

// repeated bytes real_out_additional_tx_keys = 4;
inline int MoneroTransactionSourceEntry::real_out_additional_tx_keys_size() const {
  return real_out_additional_tx_keys_.size();
}
inline void MoneroTransactionSourceEntry::clear_real_out_additional_tx_keys() {
  real_out_additional_tx_keys_.Clear();
}
inline const ::std::string& MoneroTransactionSourceEntry::real_out_additional_tx_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_.Get(index);
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_.Mutable(index);
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  real_out_additional_tx_keys_.Mutable(index)->assign(value);
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const char* value) {
  real_out_additional_tx_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::set_real_out_additional_tx_keys(int index, const void* value, size_t size) {
  real_out_additional_tx_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline ::std::string* MoneroTransactionSourceEntry::add_real_out_additional_tx_keys() {
  return real_out_additional_tx_keys_.Add();
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const ::std::string& value) {
  real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const char* value) {
  real_out_additional_tx_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline void MoneroTransactionSourceEntry::add_real_out_additional_tx_keys(const void* value, size_t size) {
  real_out_additional_tx_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MoneroTransactionSourceEntry::real_out_additional_tx_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return real_out_additional_tx_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MoneroTransactionSourceEntry::mutable_real_out_additional_tx_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_out_additional_tx_keys)
  return &real_out_additional_tx_keys_;
}

// optional uint64 real_output_in_tx_index = 5;
inline bool MoneroTransactionSourceEntry::has_real_output_in_tx_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_real_output_in_tx_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionSourceEntry::clear_has_real_output_in_tx_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionSourceEntry::clear_real_output_in_tx_index() {
  real_output_in_tx_index_ = GOOGLE_ULONGLONG(0);
  clear_has_real_output_in_tx_index();
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::real_output_in_tx_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
  return real_output_in_tx_index_;
}
inline void MoneroTransactionSourceEntry::set_real_output_in_tx_index(::google::protobuf::uint64 value) {
  set_has_real_output_in_tx_index();
  real_output_in_tx_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.real_output_in_tx_index)
}

// optional uint64 amount = 6;
inline bool MoneroTransactionSourceEntry::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionSourceEntry::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionSourceEntry::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 MoneroTransactionSourceEntry::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
  return amount_;
}
inline void MoneroTransactionSourceEntry::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.amount)
}

// optional bool rct = 7;
inline bool MoneroTransactionSourceEntry::has_rct() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_rct() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoneroTransactionSourceEntry::clear_has_rct() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoneroTransactionSourceEntry::clear_rct() {
  rct_ = false;
  clear_has_rct();
}
inline bool MoneroTransactionSourceEntry::rct() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
  return rct_;
}
inline void MoneroTransactionSourceEntry::set_rct(bool value) {
  set_has_rct();
  rct_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.rct)
}

// optional bytes mask = 8;
inline bool MoneroTransactionSourceEntry::has_mask() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_mask() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoneroTransactionSourceEntry::clear_has_mask() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoneroTransactionSourceEntry::clear_mask() {
  if (mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_->clear();
  }
  clear_has_mask();
}
inline const ::std::string& MoneroTransactionSourceEntry::mask() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return *mask_;
}
inline void MoneroTransactionSourceEntry::set_mask(const ::std::string& value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline void MoneroTransactionSourceEntry::set_mask(const char* value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline void MoneroTransactionSourceEntry::set_mask(const void* value, size_t size) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  mask_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}
inline ::std::string* MoneroTransactionSourceEntry::mutable_mask() {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mask_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
  return mask_;
}
inline ::std::string* MoneroTransactionSourceEntry::release_mask() {
  clear_has_mask();
  if (mask_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mask_;
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSourceEntry::set_allocated_mask(::std::string* mask) {
  if (mask_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mask_;
  }
  if (mask) {
    set_has_mask();
    mask_ = mask;
  } else {
    clear_has_mask();
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.mask)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;
inline bool MoneroTransactionSourceEntry::has_multisig_klrki() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoneroTransactionSourceEntry::set_has_multisig_klrki() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoneroTransactionSourceEntry::clear_has_multisig_klrki() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoneroTransactionSourceEntry::clear_multisig_klrki() {
  if (multisig_klrki_ != NULL) multisig_klrki_->::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki::Clear();
  clear_has_multisig_klrki();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki& MoneroTransactionSourceEntry::multisig_klrki() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return multisig_klrki_ != NULL ? *multisig_klrki_ : *default_instance_->multisig_klrki_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::mutable_multisig_klrki() {
  set_has_multisig_klrki();
  if (multisig_klrki_ == NULL) multisig_klrki_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
  return multisig_klrki_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* MoneroTransactionSourceEntry::release_multisig_klrki() {
  clear_has_multisig_klrki();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* temp = multisig_klrki_;
  multisig_klrki_ = NULL;
  return temp;
}
inline void MoneroTransactionSourceEntry::set_allocated_multisig_klrki(::hw::trezor::messages::monero::MoneroTransactionSourceEntry_MoneroMultisigKLRki* multisig_klrki) {
  delete multisig_klrki_;
  multisig_klrki_ = multisig_klrki;
  if (multisig_klrki) {
    set_has_multisig_klrki();
  } else {
    clear_has_multisig_klrki();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSourceEntry.multisig_kLRki)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputRequest

// optional uint32 version = 1;
inline bool MoneroTransactionSetInputRequest::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetInputRequest::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSetInputRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSetInputRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 MoneroTransactionSetInputRequest::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.version)
  return version_;
}
inline void MoneroTransactionSetInputRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.version)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 2;
inline bool MoneroTransactionSetInputRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetInputRequest::set_has_src_entr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSetInputRequest::clear_has_src_entr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSetInputRequest::clear_src_entr() {
  if (src_entr_ != NULL) src_entr_->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::Clear();
  clear_has_src_entr();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSetInputRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return src_entr_ != NULL ? *src_entr_ : *default_instance_->src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::mutable_src_entr() {
  set_has_src_entr();
  if (src_entr_ == NULL) src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
  return src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSetInputRequest::release_src_entr() {
  clear_has_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = NULL;
  return temp;
}
inline void MoneroTransactionSetInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  delete src_entr_;
  src_entr_ = src_entr;
  if (src_entr) {
    set_has_src_entr();
  } else {
    clear_has_src_entr();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputRequest.src_entr)
}

// -------------------------------------------------------------------

// MoneroTransactionSetInputAck

// optional bytes vini = 1;
inline bool MoneroTransactionSetInputAck::has_vini() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_vini() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSetInputAck::clear_has_vini() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSetInputAck::clear_vini() {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_->clear();
  }
  clear_has_vini();
}
inline const ::std::string& MoneroTransactionSetInputAck::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return *vini_;
}
inline void MoneroTransactionSetInputAck::set_vini(const ::std::string& value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline void MoneroTransactionSetInputAck::set_vini(const char* value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline void MoneroTransactionSetInputAck::set_vini(const void* value, size_t size) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_vini() {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
  return vini_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_vini() {
  clear_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_;
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_vini(::std::string* vini) {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_;
  }
  if (vini) {
    set_has_vini();
    vini_ = vini;
  } else {
    clear_has_vini();
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini)
}

// optional bytes vini_hmac = 2;
inline bool MoneroTransactionSetInputAck::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_vini_hmac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSetInputAck::clear_has_vini_hmac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSetInputAck::clear_vini_hmac() {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_->clear();
  }
  clear_has_vini_hmac();
}
inline const ::std::string& MoneroTransactionSetInputAck::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return *vini_hmac_;
}
inline void MoneroTransactionSetInputAck::set_vini_hmac(const ::std::string& value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline void MoneroTransactionSetInputAck::set_vini_hmac(const char* value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline void MoneroTransactionSetInputAck::set_vini_hmac(const void* value, size_t size) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_vini_hmac() {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
  return vini_hmac_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_vini_hmac() {
  clear_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_hmac_;
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_hmac_;
  }
  if (vini_hmac) {
    set_has_vini_hmac();
    vini_hmac_ = vini_hmac;
  } else {
    clear_has_vini_hmac();
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.vini_hmac)
}

// optional bytes pseudo_out = 3;
inline bool MoneroTransactionSetInputAck::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_pseudo_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSetInputAck::clear_has_pseudo_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out() {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_->clear();
  }
  clear_has_pseudo_out();
}
inline const ::std::string& MoneroTransactionSetInputAck::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return *pseudo_out_;
}
inline void MoneroTransactionSetInputAck::set_pseudo_out(const ::std::string& value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out(const char* value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out(const void* value, size_t size) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_pseudo_out() {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
  return pseudo_out_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_pseudo_out() {
  clear_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_;
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_;
  }
  if (pseudo_out) {
    set_has_pseudo_out();
    pseudo_out_ = pseudo_out;
  } else {
    clear_has_pseudo_out();
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out)
}

// optional bytes pseudo_out_hmac = 4;
inline bool MoneroTransactionSetInputAck::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionSetInputAck::clear_has_pseudo_out_hmac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionSetInputAck::clear_pseudo_out_hmac() {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_->clear();
  }
  clear_has_pseudo_out_hmac();
}
inline const ::std::string& MoneroTransactionSetInputAck::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return *pseudo_out_hmac_;
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const ::std::string& value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const char* value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline void MoneroTransactionSetInputAck::set_pseudo_out_hmac(const void* value, size_t size) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_pseudo_out_hmac() {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
  return pseudo_out_hmac_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_pseudo_out_hmac() {
  clear_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_hmac_;
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_hmac_;
  }
  if (pseudo_out_hmac) {
    set_has_pseudo_out_hmac();
    pseudo_out_hmac_ = pseudo_out_hmac;
  } else {
    clear_has_pseudo_out_hmac();
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.pseudo_out_hmac)
}

// optional bytes alpha_enc = 5;
inline bool MoneroTransactionSetInputAck::has_alpha_enc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_alpha_enc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionSetInputAck::clear_has_alpha_enc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionSetInputAck::clear_alpha_enc() {
  if (alpha_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_->clear();
  }
  clear_has_alpha_enc();
}
inline const ::std::string& MoneroTransactionSetInputAck::alpha_enc() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
  return *alpha_enc_;
}
inline void MoneroTransactionSetInputAck::set_alpha_enc(const ::std::string& value) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
}
inline void MoneroTransactionSetInputAck::set_alpha_enc(const char* value) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
}
inline void MoneroTransactionSetInputAck::set_alpha_enc(const void* value, size_t size) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_alpha_enc() {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
  return alpha_enc_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_alpha_enc() {
  clear_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alpha_enc_;
    alpha_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_alpha_enc(::std::string* alpha_enc) {
  if (alpha_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alpha_enc_;
  }
  if (alpha_enc) {
    set_has_alpha_enc();
    alpha_enc_ = alpha_enc;
  } else {
    clear_has_alpha_enc();
    alpha_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.alpha_enc)
}

// optional bytes spend_enc = 6;
inline bool MoneroTransactionSetInputAck::has_spend_enc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSetInputAck::set_has_spend_enc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionSetInputAck::clear_has_spend_enc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionSetInputAck::clear_spend_enc() {
  if (spend_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_->clear();
  }
  clear_has_spend_enc();
}
inline const ::std::string& MoneroTransactionSetInputAck::spend_enc() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
  return *spend_enc_;
}
inline void MoneroTransactionSetInputAck::set_spend_enc(const ::std::string& value) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
}
inline void MoneroTransactionSetInputAck::set_spend_enc(const char* value) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
}
inline void MoneroTransactionSetInputAck::set_spend_enc(const void* value, size_t size) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
}
inline ::std::string* MoneroTransactionSetInputAck::mutable_spend_enc() {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
  return spend_enc_;
}
inline ::std::string* MoneroTransactionSetInputAck::release_spend_enc() {
  clear_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = spend_enc_;
    spend_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetInputAck::set_allocated_spend_enc(::std::string* spend_enc) {
  if (spend_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete spend_enc_;
  }
  if (spend_enc) {
    set_has_spend_enc();
    spend_enc_ = spend_enc;
  } else {
    clear_has_spend_enc();
    spend_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetInputAck.spend_enc)
}

// -------------------------------------------------------------------

// MoneroTransactionInputsPermutationRequest

// repeated uint32 perm = 1;
inline int MoneroTransactionInputsPermutationRequest::perm_size() const {
  return perm_.size();
}
inline void MoneroTransactionInputsPermutationRequest::clear_perm() {
  perm_.Clear();
}
inline ::google::protobuf::uint32 MoneroTransactionInputsPermutationRequest::perm(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return perm_.Get(index);
}
inline void MoneroTransactionInputsPermutationRequest::set_perm(int index, ::google::protobuf::uint32 value) {
  perm_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
}
inline void MoneroTransactionInputsPermutationRequest::add_perm(::google::protobuf::uint32 value) {
  perm_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroTransactionInputsPermutationRequest::perm() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return perm_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroTransactionInputsPermutationRequest::mutable_perm() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest.perm)
  return &perm_;
}

// -------------------------------------------------------------------

// MoneroTransactionInputsPermutationAck

// -------------------------------------------------------------------

// MoneroTransactionInputViniRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionInputViniRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionInputViniRequest::set_has_src_entr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionInputViniRequest::clear_has_src_entr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionInputViniRequest::clear_src_entr() {
  if (src_entr_ != NULL) src_entr_->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::Clear();
  clear_has_src_entr();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionInputViniRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return src_entr_ != NULL ? *src_entr_ : *default_instance_->src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::mutable_src_entr() {
  set_has_src_entr();
  if (src_entr_ == NULL) src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
  return src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionInputViniRequest::release_src_entr() {
  clear_has_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = NULL;
  return temp;
}
inline void MoneroTransactionInputViniRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  delete src_entr_;
  src_entr_ = src_entr;
  if (src_entr) {
    set_has_src_entr();
  } else {
    clear_has_src_entr();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionInputViniRequest::has_vini() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionInputViniRequest::set_has_vini() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionInputViniRequest::clear_has_vini() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionInputViniRequest::clear_vini() {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_->clear();
  }
  clear_has_vini();
}
inline const ::std::string& MoneroTransactionInputViniRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return *vini_;
}
inline void MoneroTransactionInputViniRequest::set_vini(const ::std::string& value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline void MoneroTransactionInputViniRequest::set_vini(const char* value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline void MoneroTransactionInputViniRequest::set_vini(const void* value, size_t size) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_vini() {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
  return vini_;
}
inline ::std::string* MoneroTransactionInputViniRequest::release_vini() {
  clear_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_;
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini(::std::string* vini) {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_;
  }
  if (vini) {
    set_has_vini();
    vini_ = vini;
  } else {
    clear_has_vini();
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionInputViniRequest::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionInputViniRequest::set_has_vini_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionInputViniRequest::clear_has_vini_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionInputViniRequest::clear_vini_hmac() {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_->clear();
  }
  clear_has_vini_hmac();
}
inline const ::std::string& MoneroTransactionInputViniRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return *vini_hmac_;
}
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const ::std::string& value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const char* value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline void MoneroTransactionInputViniRequest::set_vini_hmac(const void* value, size_t size) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_vini_hmac() {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
  return vini_hmac_;
}
inline ::std::string* MoneroTransactionInputViniRequest::release_vini_hmac() {
  clear_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_hmac_;
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInputViniRequest::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_hmac_;
  }
  if (vini_hmac) {
    set_has_vini_hmac();
    vini_hmac_ = vini_hmac;
  } else {
    clear_has_vini_hmac();
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionInputViniRequest::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionInputViniRequest::set_has_pseudo_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionInputViniRequest::clear_has_pseudo_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out() {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_->clear();
  }
  clear_has_pseudo_out();
}
inline const ::std::string& MoneroTransactionInputViniRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return *pseudo_out_;
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const ::std::string& value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const char* value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out(const void* value, size_t size) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out() {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
  return pseudo_out_;
}
inline ::std::string* MoneroTransactionInputViniRequest::release_pseudo_out() {
  clear_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_;
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_;
  }
  if (pseudo_out) {
    set_has_pseudo_out();
    pseudo_out_ = pseudo_out;
  } else {
    clear_has_pseudo_out();
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionInputViniRequest::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionInputViniRequest::set_has_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionInputViniRequest::clear_has_pseudo_out_hmac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionInputViniRequest::clear_pseudo_out_hmac() {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_->clear();
  }
  clear_has_pseudo_out_hmac();
}
inline const ::std::string& MoneroTransactionInputViniRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return *pseudo_out_hmac_;
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const ::std::string& value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const char* value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline void MoneroTransactionInputViniRequest::set_pseudo_out_hmac(const void* value, size_t size) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionInputViniRequest::mutable_pseudo_out_hmac() {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
  return pseudo_out_hmac_;
}
inline ::std::string* MoneroTransactionInputViniRequest::release_pseudo_out_hmac() {
  clear_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_hmac_;
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionInputViniRequest::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_hmac_;
  }
  if (pseudo_out_hmac) {
    set_has_pseudo_out_hmac();
    pseudo_out_hmac_ = pseudo_out_hmac;
  } else {
    clear_has_pseudo_out_hmac();
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionInputViniRequest.pseudo_out_hmac)
}

// -------------------------------------------------------------------

// MoneroTransactionInputViniAck

// -------------------------------------------------------------------

// MoneroTransactionSetOutputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;
inline bool MoneroTransactionSetOutputRequest::has_dst_entr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetOutputRequest::set_has_dst_entr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSetOutputRequest::clear_has_dst_entr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr() {
  if (dst_entr_ != NULL) dst_entr_->::hw::trezor::messages::monero::MoneroTransactionDestinationEntry::Clear();
  clear_has_dst_entr();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry& MoneroTransactionSetOutputRequest::dst_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return dst_entr_ != NULL ? *dst_entr_ : *default_instance_->dst_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::mutable_dst_entr() {
  set_has_dst_entr();
  if (dst_entr_ == NULL) dst_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
  return dst_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* MoneroTransactionSetOutputRequest::release_dst_entr() {
  clear_has_dst_entr();
  ::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* temp = dst_entr_;
  dst_entr_ = NULL;
  return temp;
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr(::hw::trezor::messages::monero::MoneroTransactionDestinationEntry* dst_entr) {
  delete dst_entr_;
  dst_entr_ = dst_entr;
  if (dst_entr) {
    set_has_dst_entr();
  } else {
    clear_has_dst_entr();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr)
}

// optional bytes dst_entr_hmac = 2;
inline bool MoneroTransactionSetOutputRequest::has_dst_entr_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetOutputRequest::set_has_dst_entr_hmac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSetOutputRequest::clear_has_dst_entr_hmac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSetOutputRequest::clear_dst_entr_hmac() {
  if (dst_entr_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dst_entr_hmac_->clear();
  }
  clear_has_dst_entr_hmac();
}
inline const ::std::string& MoneroTransactionSetOutputRequest::dst_entr_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return *dst_entr_hmac_;
}
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const ::std::string& value) {
  set_has_dst_entr_hmac();
  if (dst_entr_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dst_entr_hmac_ = new ::std::string;
  }
  dst_entr_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const char* value) {
  set_has_dst_entr_hmac();
  if (dst_entr_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dst_entr_hmac_ = new ::std::string;
  }
  dst_entr_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline void MoneroTransactionSetOutputRequest::set_dst_entr_hmac(const void* value, size_t size) {
  set_has_dst_entr_hmac();
  if (dst_entr_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dst_entr_hmac_ = new ::std::string;
  }
  dst_entr_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}
inline ::std::string* MoneroTransactionSetOutputRequest::mutable_dst_entr_hmac() {
  set_has_dst_entr_hmac();
  if (dst_entr_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dst_entr_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
  return dst_entr_hmac_;
}
inline ::std::string* MoneroTransactionSetOutputRequest::release_dst_entr_hmac() {
  clear_has_dst_entr_hmac();
  if (dst_entr_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dst_entr_hmac_;
    dst_entr_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputRequest::set_allocated_dst_entr_hmac(::std::string* dst_entr_hmac) {
  if (dst_entr_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dst_entr_hmac_;
  }
  if (dst_entr_hmac) {
    set_has_dst_entr_hmac();
    dst_entr_hmac_ = dst_entr_hmac;
  } else {
    clear_has_dst_entr_hmac();
    dst_entr_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputRequest.dst_entr_hmac)
}

// -------------------------------------------------------------------

// MoneroTransactionSetOutputAck

// optional bytes tx_out = 1;
inline bool MoneroTransactionSetOutputAck::has_tx_out() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSetOutputAck::set_has_tx_out() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSetOutputAck::clear_has_tx_out() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSetOutputAck::clear_tx_out() {
  if (tx_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_out_->clear();
  }
  clear_has_tx_out();
}
inline const ::std::string& MoneroTransactionSetOutputAck::tx_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return *tx_out_;
}
inline void MoneroTransactionSetOutputAck::set_tx_out(const ::std::string& value) {
  set_has_tx_out();
  if (tx_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_out_ = new ::std::string;
  }
  tx_out_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline void MoneroTransactionSetOutputAck::set_tx_out(const char* value) {
  set_has_tx_out();
  if (tx_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_out_ = new ::std::string;
  }
  tx_out_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline void MoneroTransactionSetOutputAck::set_tx_out(const void* value, size_t size) {
  set_has_tx_out();
  if (tx_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_out_ = new ::std::string;
  }
  tx_out_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_tx_out() {
  set_has_tx_out();
  if (tx_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_out_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
  return tx_out_;
}
inline ::std::string* MoneroTransactionSetOutputAck::release_tx_out() {
  clear_has_tx_out();
  if (tx_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_out_;
    tx_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputAck::set_allocated_tx_out(::std::string* tx_out) {
  if (tx_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_out_;
  }
  if (tx_out) {
    set_has_tx_out();
    tx_out_ = tx_out;
  } else {
    clear_has_tx_out();
    tx_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.tx_out)
}

// optional bytes vouti_hmac = 2;
inline bool MoneroTransactionSetOutputAck::has_vouti_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSetOutputAck::set_has_vouti_hmac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSetOutputAck::clear_has_vouti_hmac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSetOutputAck::clear_vouti_hmac() {
  if (vouti_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vouti_hmac_->clear();
  }
  clear_has_vouti_hmac();
}
inline const ::std::string& MoneroTransactionSetOutputAck::vouti_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return *vouti_hmac_;
}
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const ::std::string& value) {
  set_has_vouti_hmac();
  if (vouti_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vouti_hmac_ = new ::std::string;
  }
  vouti_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const char* value) {
  set_has_vouti_hmac();
  if (vouti_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vouti_hmac_ = new ::std::string;
  }
  vouti_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline void MoneroTransactionSetOutputAck::set_vouti_hmac(const void* value, size_t size) {
  set_has_vouti_hmac();
  if (vouti_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vouti_hmac_ = new ::std::string;
  }
  vouti_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_vouti_hmac() {
  set_has_vouti_hmac();
  if (vouti_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vouti_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
  return vouti_hmac_;
}
inline ::std::string* MoneroTransactionSetOutputAck::release_vouti_hmac() {
  clear_has_vouti_hmac();
  if (vouti_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vouti_hmac_;
    vouti_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputAck::set_allocated_vouti_hmac(::std::string* vouti_hmac) {
  if (vouti_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vouti_hmac_;
  }
  if (vouti_hmac) {
    set_has_vouti_hmac();
    vouti_hmac_ = vouti_hmac;
  } else {
    clear_has_vouti_hmac();
    vouti_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.vouti_hmac)
}

// optional bytes rsig = 3;
inline bool MoneroTransactionSetOutputAck::has_rsig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSetOutputAck::set_has_rsig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSetOutputAck::clear_has_rsig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSetOutputAck::clear_rsig() {
  if (rsig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsig_->clear();
  }
  clear_has_rsig();
}
inline const ::std::string& MoneroTransactionSetOutputAck::rsig() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
  return *rsig_;
}
inline void MoneroTransactionSetOutputAck::set_rsig(const ::std::string& value) {
  set_has_rsig();
  if (rsig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsig_ = new ::std::string;
  }
  rsig_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
}
inline void MoneroTransactionSetOutputAck::set_rsig(const char* value) {
  set_has_rsig();
  if (rsig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsig_ = new ::std::string;
  }
  rsig_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
}
inline void MoneroTransactionSetOutputAck::set_rsig(const void* value, size_t size) {
  set_has_rsig();
  if (rsig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsig_ = new ::std::string;
  }
  rsig_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_rsig() {
  set_has_rsig();
  if (rsig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rsig_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
  return rsig_;
}
inline ::std::string* MoneroTransactionSetOutputAck::release_rsig() {
  clear_has_rsig();
  if (rsig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rsig_;
    rsig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputAck::set_allocated_rsig(::std::string* rsig) {
  if (rsig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rsig_;
  }
  if (rsig) {
    set_has_rsig();
    rsig_ = rsig;
  } else {
    clear_has_rsig();
    rsig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.rsig)
}

// optional bytes out_pk = 4;
inline bool MoneroTransactionSetOutputAck::has_out_pk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSetOutputAck::set_has_out_pk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionSetOutputAck::clear_has_out_pk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionSetOutputAck::clear_out_pk() {
  if (out_pk_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_pk_->clear();
  }
  clear_has_out_pk();
}
inline const ::std::string& MoneroTransactionSetOutputAck::out_pk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return *out_pk_;
}
inline void MoneroTransactionSetOutputAck::set_out_pk(const ::std::string& value) {
  set_has_out_pk();
  if (out_pk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_pk_ = new ::std::string;
  }
  out_pk_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline void MoneroTransactionSetOutputAck::set_out_pk(const char* value) {
  set_has_out_pk();
  if (out_pk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_pk_ = new ::std::string;
  }
  out_pk_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline void MoneroTransactionSetOutputAck::set_out_pk(const void* value, size_t size) {
  set_has_out_pk();
  if (out_pk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_pk_ = new ::std::string;
  }
  out_pk_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_out_pk() {
  set_has_out_pk();
  if (out_pk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_pk_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
  return out_pk_;
}
inline ::std::string* MoneroTransactionSetOutputAck::release_out_pk() {
  clear_has_out_pk();
  if (out_pk_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = out_pk_;
    out_pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputAck::set_allocated_out_pk(::std::string* out_pk) {
  if (out_pk_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete out_pk_;
  }
  if (out_pk) {
    set_has_out_pk();
    out_pk_ = out_pk;
  } else {
    clear_has_out_pk();
    out_pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.out_pk)
}

// optional bytes ecdh_info = 5;
inline bool MoneroTransactionSetOutputAck::has_ecdh_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSetOutputAck::set_has_ecdh_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionSetOutputAck::clear_has_ecdh_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionSetOutputAck::clear_ecdh_info() {
  if (ecdh_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdh_info_->clear();
  }
  clear_has_ecdh_info();
}
inline const ::std::string& MoneroTransactionSetOutputAck::ecdh_info() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return *ecdh_info_;
}
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const ::std::string& value) {
  set_has_ecdh_info();
  if (ecdh_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdh_info_ = new ::std::string;
  }
  ecdh_info_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const char* value) {
  set_has_ecdh_info();
  if (ecdh_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdh_info_ = new ::std::string;
  }
  ecdh_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline void MoneroTransactionSetOutputAck::set_ecdh_info(const void* value, size_t size) {
  set_has_ecdh_info();
  if (ecdh_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdh_info_ = new ::std::string;
  }
  ecdh_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}
inline ::std::string* MoneroTransactionSetOutputAck::mutable_ecdh_info() {
  set_has_ecdh_info();
  if (ecdh_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ecdh_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
  return ecdh_info_;
}
inline ::std::string* MoneroTransactionSetOutputAck::release_ecdh_info() {
  clear_has_ecdh_info();
  if (ecdh_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ecdh_info_;
    ecdh_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSetOutputAck::set_allocated_ecdh_info(::std::string* ecdh_info) {
  if (ecdh_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ecdh_info_;
  }
  if (ecdh_info) {
    set_has_ecdh_info();
    ecdh_info_ = ecdh_info;
  } else {
    clear_has_ecdh_info();
    ecdh_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSetOutputAck.ecdh_info)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetRequest

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck_MoneroRingCtSig

// optional uint64 txn_fee = 1;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_txn_fee() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_has_txn_fee() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_has_txn_fee() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_txn_fee() {
  txn_fee_ = GOOGLE_ULONGLONG(0);
  clear_has_txn_fee();
}
inline ::google::protobuf::uint64 MoneroTransactionAllOutSetAck_MoneroRingCtSig::txn_fee() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
  return txn_fee_;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_txn_fee(::google::protobuf::uint64 value) {
  set_has_txn_fee();
  txn_fee_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.txn_fee)
}

// optional bytes message = 2;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& MoneroTransactionAllOutSetAck_MoneroRingCtSig::message() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return *message_;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}
inline ::std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
  return message_;
}
inline ::std::string* MoneroTransactionAllOutSetAck_MoneroRingCtSig::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.message)
}

// optional uint32 rv_type = 3;
inline bool MoneroTransactionAllOutSetAck_MoneroRingCtSig::has_rv_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_has_rv_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_has_rv_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::clear_rv_type() {
  rv_type_ = 0u;
  clear_has_rv_type();
}
inline ::google::protobuf::uint32 MoneroTransactionAllOutSetAck_MoneroRingCtSig::rv_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
  return rv_type_;
}
inline void MoneroTransactionAllOutSetAck_MoneroRingCtSig::set_rv_type(::google::protobuf::uint32 value) {
  set_has_rv_type();
  rv_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig.rv_type)
}

// -------------------------------------------------------------------

// MoneroTransactionAllOutSetAck

// optional bytes extra = 1;
inline bool MoneroTransactionAllOutSetAck::has_extra() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionAllOutSetAck::set_has_extra() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionAllOutSetAck::clear_has_extra() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionAllOutSetAck::clear_extra() {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_->clear();
  }
  clear_has_extra();
}
inline const ::std::string& MoneroTransactionAllOutSetAck::extra() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return *extra_;
}
inline void MoneroTransactionAllOutSetAck::set_extra(const ::std::string& value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline void MoneroTransactionAllOutSetAck::set_extra(const char* value) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline void MoneroTransactionAllOutSetAck::set_extra(const void* value, size_t size) {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}
inline ::std::string* MoneroTransactionAllOutSetAck::mutable_extra() {
  set_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
  return extra_;
}
inline ::std::string* MoneroTransactionAllOutSetAck::release_extra() {
  clear_has_extra();
  if (extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extra_;
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionAllOutSetAck::set_allocated_extra(::std::string* extra) {
  if (extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_;
  }
  if (extra) {
    set_has_extra();
    extra_ = extra;
  } else {
    clear_has_extra();
    extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.extra)
}

// optional bytes tx_prefix_hash = 2;
inline bool MoneroTransactionAllOutSetAck::has_tx_prefix_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionAllOutSetAck::set_has_tx_prefix_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionAllOutSetAck::clear_has_tx_prefix_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionAllOutSetAck::clear_tx_prefix_hash() {
  if (tx_prefix_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_prefix_hash_->clear();
  }
  clear_has_tx_prefix_hash();
}
inline const ::std::string& MoneroTransactionAllOutSetAck::tx_prefix_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return *tx_prefix_hash_;
}
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const ::std::string& value) {
  set_has_tx_prefix_hash();
  if (tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_prefix_hash_ = new ::std::string;
  }
  tx_prefix_hash_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const char* value) {
  set_has_tx_prefix_hash();
  if (tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_prefix_hash_ = new ::std::string;
  }
  tx_prefix_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline void MoneroTransactionAllOutSetAck::set_tx_prefix_hash(const void* value, size_t size) {
  set_has_tx_prefix_hash();
  if (tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_prefix_hash_ = new ::std::string;
  }
  tx_prefix_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}
inline ::std::string* MoneroTransactionAllOutSetAck::mutable_tx_prefix_hash() {
  set_has_tx_prefix_hash();
  if (tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_prefix_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
  return tx_prefix_hash_;
}
inline ::std::string* MoneroTransactionAllOutSetAck::release_tx_prefix_hash() {
  clear_has_tx_prefix_hash();
  if (tx_prefix_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_prefix_hash_;
    tx_prefix_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionAllOutSetAck::set_allocated_tx_prefix_hash(::std::string* tx_prefix_hash) {
  if (tx_prefix_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_prefix_hash_;
  }
  if (tx_prefix_hash) {
    set_has_tx_prefix_hash();
    tx_prefix_hash_ = tx_prefix_hash;
  } else {
    clear_has_tx_prefix_hash();
    tx_prefix_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.tx_prefix_hash)
}

// optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 3;
inline bool MoneroTransactionAllOutSetAck::has_rv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionAllOutSetAck::set_has_rv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionAllOutSetAck::clear_has_rv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionAllOutSetAck::clear_rv() {
  if (rv_ != NULL) rv_->::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig::Clear();
  clear_has_rv();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig& MoneroTransactionAllOutSetAck::rv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return rv_ != NULL ? *rv_ : *default_instance_->rv_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::mutable_rv() {
  set_has_rv();
  if (rv_ == NULL) rv_ = new ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
  return rv_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* MoneroTransactionAllOutSetAck::release_rv() {
  clear_has_rv();
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* temp = rv_;
  rv_ = NULL;
  return temp;
}
inline void MoneroTransactionAllOutSetAck::set_allocated_rv(::hw::trezor::messages::monero::MoneroTransactionAllOutSetAck_MoneroRingCtSig* rv) {
  delete rv_;
  rv_ = rv;
  if (rv) {
    set_has_rv();
  } else {
    clear_has_rv();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.rv)
}

// -------------------------------------------------------------------

// MoneroTransactionMlsagDoneRequest

// -------------------------------------------------------------------

// MoneroTransactionMlsagDoneAck

// optional bytes full_message_hash = 1;
inline bool MoneroTransactionMlsagDoneAck::has_full_message_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionMlsagDoneAck::set_has_full_message_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionMlsagDoneAck::clear_has_full_message_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionMlsagDoneAck::clear_full_message_hash() {
  if (full_message_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    full_message_hash_->clear();
  }
  clear_has_full_message_hash();
}
inline const ::std::string& MoneroTransactionMlsagDoneAck::full_message_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
  return *full_message_hash_;
}
inline void MoneroTransactionMlsagDoneAck::set_full_message_hash(const ::std::string& value) {
  set_has_full_message_hash();
  if (full_message_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    full_message_hash_ = new ::std::string;
  }
  full_message_hash_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
}
inline void MoneroTransactionMlsagDoneAck::set_full_message_hash(const char* value) {
  set_has_full_message_hash();
  if (full_message_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    full_message_hash_ = new ::std::string;
  }
  full_message_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
}
inline void MoneroTransactionMlsagDoneAck::set_full_message_hash(const void* value, size_t size) {
  set_has_full_message_hash();
  if (full_message_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    full_message_hash_ = new ::std::string;
  }
  full_message_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
}
inline ::std::string* MoneroTransactionMlsagDoneAck::mutable_full_message_hash() {
  set_has_full_message_hash();
  if (full_message_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    full_message_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
  return full_message_hash_;
}
inline ::std::string* MoneroTransactionMlsagDoneAck::release_full_message_hash() {
  clear_has_full_message_hash();
  if (full_message_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = full_message_hash_;
    full_message_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionMlsagDoneAck::set_allocated_full_message_hash(::std::string* full_message_hash) {
  if (full_message_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete full_message_hash_;
  }
  if (full_message_hash) {
    set_has_full_message_hash();
    full_message_hash_ = full_message_hash;
  } else {
    clear_has_full_message_hash();
    full_message_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionMlsagDoneAck.full_message_hash)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputRequest

// optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;
inline bool MoneroTransactionSignInputRequest::has_src_entr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_src_entr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSignInputRequest::clear_has_src_entr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSignInputRequest::clear_src_entr() {
  if (src_entr_ != NULL) src_entr_->::hw::trezor::messages::monero::MoneroTransactionSourceEntry::Clear();
  clear_has_src_entr();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSourceEntry& MoneroTransactionSignInputRequest::src_entr() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return src_entr_ != NULL ? *src_entr_ : *default_instance_->src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::mutable_src_entr() {
  set_has_src_entr();
  if (src_entr_ == NULL) src_entr_ = new ::hw::trezor::messages::monero::MoneroTransactionSourceEntry;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
  return src_entr_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* MoneroTransactionSignInputRequest::release_src_entr() {
  clear_has_src_entr();
  ::hw::trezor::messages::monero::MoneroTransactionSourceEntry* temp = src_entr_;
  src_entr_ = NULL;
  return temp;
}
inline void MoneroTransactionSignInputRequest::set_allocated_src_entr(::hw::trezor::messages::monero::MoneroTransactionSourceEntry* src_entr) {
  delete src_entr_;
  src_entr_ = src_entr;
  if (src_entr) {
    set_has_src_entr();
  } else {
    clear_has_src_entr();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.src_entr)
}

// optional bytes vini = 2;
inline bool MoneroTransactionSignInputRequest::has_vini() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_vini() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSignInputRequest::clear_has_vini() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSignInputRequest::clear_vini() {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_->clear();
  }
  clear_has_vini();
}
inline const ::std::string& MoneroTransactionSignInputRequest::vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return *vini_;
}
inline void MoneroTransactionSignInputRequest::set_vini(const ::std::string& value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline void MoneroTransactionSignInputRequest::set_vini(const char* value) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline void MoneroTransactionSignInputRequest::set_vini(const void* value, size_t size) {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  vini_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_vini() {
  set_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
  return vini_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_vini() {
  clear_has_vini();
  if (vini_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_;
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini(::std::string* vini) {
  if (vini_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_;
  }
  if (vini) {
    set_has_vini();
    vini_ = vini;
  } else {
    clear_has_vini();
    vini_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini)
}

// optional bytes vini_hmac = 3;
inline bool MoneroTransactionSignInputRequest::has_vini_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_vini_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSignInputRequest::clear_has_vini_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSignInputRequest::clear_vini_hmac() {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_->clear();
  }
  clear_has_vini_hmac();
}
inline const ::std::string& MoneroTransactionSignInputRequest::vini_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return *vini_hmac_;
}
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const ::std::string& value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const char* value) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline void MoneroTransactionSignInputRequest::set_vini_hmac(const void* value, size_t size) {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  vini_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_vini_hmac() {
  set_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vini_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
  return vini_hmac_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_vini_hmac() {
  clear_has_vini_hmac();
  if (vini_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vini_hmac_;
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_vini_hmac(::std::string* vini_hmac) {
  if (vini_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vini_hmac_;
  }
  if (vini_hmac) {
    set_has_vini_hmac();
    vini_hmac_ = vini_hmac;
  } else {
    clear_has_vini_hmac();
    vini_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.vini_hmac)
}

// optional bytes pseudo_out = 4;
inline bool MoneroTransactionSignInputRequest::has_pseudo_out() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_pseudo_out() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionSignInputRequest::clear_has_pseudo_out() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out() {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_->clear();
  }
  clear_has_pseudo_out();
}
inline const ::std::string& MoneroTransactionSignInputRequest::pseudo_out() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return *pseudo_out_;
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const ::std::string& value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const char* value) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out(const void* value, size_t size) {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  pseudo_out_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out() {
  set_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
  return pseudo_out_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_pseudo_out() {
  clear_has_pseudo_out();
  if (pseudo_out_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_;
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out(::std::string* pseudo_out) {
  if (pseudo_out_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_;
  }
  if (pseudo_out) {
    set_has_pseudo_out();
    pseudo_out_ = pseudo_out;
  } else {
    clear_has_pseudo_out();
    pseudo_out_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out)
}

// optional bytes pseudo_out_hmac = 5;
inline bool MoneroTransactionSignInputRequest::has_pseudo_out_hmac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_pseudo_out_hmac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionSignInputRequest::clear_has_pseudo_out_hmac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionSignInputRequest::clear_pseudo_out_hmac() {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_->clear();
  }
  clear_has_pseudo_out_hmac();
}
inline const ::std::string& MoneroTransactionSignInputRequest::pseudo_out_hmac() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return *pseudo_out_hmac_;
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const ::std::string& value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const char* value) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline void MoneroTransactionSignInputRequest::set_pseudo_out_hmac(const void* value, size_t size) {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  pseudo_out_hmac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_pseudo_out_hmac() {
  set_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pseudo_out_hmac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
  return pseudo_out_hmac_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_pseudo_out_hmac() {
  clear_has_pseudo_out_hmac();
  if (pseudo_out_hmac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_out_hmac_;
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_pseudo_out_hmac(::std::string* pseudo_out_hmac) {
  if (pseudo_out_hmac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pseudo_out_hmac_;
  }
  if (pseudo_out_hmac) {
    set_has_pseudo_out_hmac();
    pseudo_out_hmac_ = pseudo_out_hmac;
  } else {
    clear_has_pseudo_out_hmac();
    pseudo_out_hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.pseudo_out_hmac)
}

// optional bytes alpha_enc = 6;
inline bool MoneroTransactionSignInputRequest::has_alpha_enc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_alpha_enc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionSignInputRequest::clear_has_alpha_enc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionSignInputRequest::clear_alpha_enc() {
  if (alpha_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_->clear();
  }
  clear_has_alpha_enc();
}
inline const ::std::string& MoneroTransactionSignInputRequest::alpha_enc() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
  return *alpha_enc_;
}
inline void MoneroTransactionSignInputRequest::set_alpha_enc(const ::std::string& value) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
}
inline void MoneroTransactionSignInputRequest::set_alpha_enc(const char* value) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
}
inline void MoneroTransactionSignInputRequest::set_alpha_enc(const void* value, size_t size) {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  alpha_enc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_alpha_enc() {
  set_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alpha_enc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
  return alpha_enc_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_alpha_enc() {
  clear_has_alpha_enc();
  if (alpha_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alpha_enc_;
    alpha_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_alpha_enc(::std::string* alpha_enc) {
  if (alpha_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alpha_enc_;
  }
  if (alpha_enc) {
    set_has_alpha_enc();
    alpha_enc_ = alpha_enc;
  } else {
    clear_has_alpha_enc();
    alpha_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.alpha_enc)
}

// optional bytes spend_enc = 7;
inline bool MoneroTransactionSignInputRequest::has_spend_enc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionSignInputRequest::set_has_spend_enc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoneroTransactionSignInputRequest::clear_has_spend_enc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoneroTransactionSignInputRequest::clear_spend_enc() {
  if (spend_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_->clear();
  }
  clear_has_spend_enc();
}
inline const ::std::string& MoneroTransactionSignInputRequest::spend_enc() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
  return *spend_enc_;
}
inline void MoneroTransactionSignInputRequest::set_spend_enc(const ::std::string& value) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
}
inline void MoneroTransactionSignInputRequest::set_spend_enc(const char* value) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
}
inline void MoneroTransactionSignInputRequest::set_spend_enc(const void* value, size_t size) {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  spend_enc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
}
inline ::std::string* MoneroTransactionSignInputRequest::mutable_spend_enc() {
  set_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    spend_enc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
  return spend_enc_;
}
inline ::std::string* MoneroTransactionSignInputRequest::release_spend_enc() {
  clear_has_spend_enc();
  if (spend_enc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = spend_enc_;
    spend_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputRequest::set_allocated_spend_enc(::std::string* spend_enc) {
  if (spend_enc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete spend_enc_;
  }
  if (spend_enc) {
    set_has_spend_enc();
    spend_enc_ = spend_enc;
  } else {
    clear_has_spend_enc();
    spend_enc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputRequest.spend_enc)
}

// -------------------------------------------------------------------

// MoneroTransactionSignInputAck

// optional bytes signature = 1;
inline bool MoneroTransactionSignInputAck::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSignInputAck::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSignInputAck::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSignInputAck::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& MoneroTransactionSignInputAck::signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return *signature_;
}
inline void MoneroTransactionSignInputAck::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline void MoneroTransactionSignInputAck::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline void MoneroTransactionSignInputAck::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}
inline ::std::string* MoneroTransactionSignInputAck::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
  return signature_;
}
inline ::std::string* MoneroTransactionSignInputAck::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputAck::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputAck.signature)
}

// optional bytes cout = 2;
inline bool MoneroTransactionSignInputAck::has_cout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSignInputAck::set_has_cout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSignInputAck::clear_has_cout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSignInputAck::clear_cout() {
  if (cout_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_->clear();
  }
  clear_has_cout();
}
inline const ::std::string& MoneroTransactionSignInputAck::cout() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
  return *cout_;
}
inline void MoneroTransactionSignInputAck::set_cout(const ::std::string& value) {
  set_has_cout();
  if (cout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_ = new ::std::string;
  }
  cout_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
}
inline void MoneroTransactionSignInputAck::set_cout(const char* value) {
  set_has_cout();
  if (cout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_ = new ::std::string;
  }
  cout_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
}
inline void MoneroTransactionSignInputAck::set_cout(const void* value, size_t size) {
  set_has_cout();
  if (cout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_ = new ::std::string;
  }
  cout_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
}
inline ::std::string* MoneroTransactionSignInputAck::mutable_cout() {
  set_has_cout();
  if (cout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
  return cout_;
}
inline ::std::string* MoneroTransactionSignInputAck::release_cout() {
  clear_has_cout();
  if (cout_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cout_;
    cout_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionSignInputAck::set_allocated_cout(::std::string* cout) {
  if (cout_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cout_;
  }
  if (cout) {
    set_has_cout();
    cout_ = cout;
  } else {
    clear_has_cout();
    cout_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignInputAck.cout)
}

// -------------------------------------------------------------------

// MoneroTransactionFinalRequest

// -------------------------------------------------------------------

// MoneroTransactionFinalAck

// optional bytes cout_key = 1;
inline bool MoneroTransactionFinalAck::has_cout_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionFinalAck::set_has_cout_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionFinalAck::clear_has_cout_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionFinalAck::clear_cout_key() {
  if (cout_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_key_->clear();
  }
  clear_has_cout_key();
}
inline const ::std::string& MoneroTransactionFinalAck::cout_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return *cout_key_;
}
inline void MoneroTransactionFinalAck::set_cout_key(const ::std::string& value) {
  set_has_cout_key();
  if (cout_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_key_ = new ::std::string;
  }
  cout_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline void MoneroTransactionFinalAck::set_cout_key(const char* value) {
  set_has_cout_key();
  if (cout_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_key_ = new ::std::string;
  }
  cout_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline void MoneroTransactionFinalAck::set_cout_key(const void* value, size_t size) {
  set_has_cout_key();
  if (cout_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_key_ = new ::std::string;
  }
  cout_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_cout_key() {
  set_has_cout_key();
  if (cout_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cout_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
  return cout_key_;
}
inline ::std::string* MoneroTransactionFinalAck::release_cout_key() {
  clear_has_cout_key();
  if (cout_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cout_key_;
    cout_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionFinalAck::set_allocated_cout_key(::std::string* cout_key) {
  if (cout_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cout_key_;
  }
  if (cout_key) {
    set_has_cout_key();
    cout_key_ = cout_key;
  } else {
    clear_has_cout_key();
    cout_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.cout_key)
}

// optional bytes salt = 2;
inline bool MoneroTransactionFinalAck::has_salt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionFinalAck::set_has_salt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionFinalAck::clear_has_salt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionFinalAck::clear_salt() {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& MoneroTransactionFinalAck::salt() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return *salt_;
}
inline void MoneroTransactionFinalAck::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline void MoneroTransactionFinalAck::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline void MoneroTransactionFinalAck::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    salt_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
  return salt_;
}
inline ::std::string* MoneroTransactionFinalAck::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionFinalAck::set_allocated_salt(::std::string* salt) {
  if (salt_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete salt_;
  }
  if (salt) {
    set_has_salt();
    salt_ = salt;
  } else {
    clear_has_salt();
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.salt)
}

// optional bytes rand_mult = 3;
inline bool MoneroTransactionFinalAck::has_rand_mult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionFinalAck::set_has_rand_mult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionFinalAck::clear_has_rand_mult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionFinalAck::clear_rand_mult() {
  if (rand_mult_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rand_mult_->clear();
  }
  clear_has_rand_mult();
}
inline const ::std::string& MoneroTransactionFinalAck::rand_mult() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return *rand_mult_;
}
inline void MoneroTransactionFinalAck::set_rand_mult(const ::std::string& value) {
  set_has_rand_mult();
  if (rand_mult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rand_mult_ = new ::std::string;
  }
  rand_mult_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline void MoneroTransactionFinalAck::set_rand_mult(const char* value) {
  set_has_rand_mult();
  if (rand_mult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rand_mult_ = new ::std::string;
  }
  rand_mult_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline void MoneroTransactionFinalAck::set_rand_mult(const void* value, size_t size) {
  set_has_rand_mult();
  if (rand_mult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rand_mult_ = new ::std::string;
  }
  rand_mult_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_rand_mult() {
  set_has_rand_mult();
  if (rand_mult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rand_mult_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
  return rand_mult_;
}
inline ::std::string* MoneroTransactionFinalAck::release_rand_mult() {
  clear_has_rand_mult();
  if (rand_mult_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rand_mult_;
    rand_mult_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionFinalAck::set_allocated_rand_mult(::std::string* rand_mult) {
  if (rand_mult_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rand_mult_;
  }
  if (rand_mult) {
    set_has_rand_mult();
    rand_mult_ = rand_mult;
  } else {
    clear_has_rand_mult();
    rand_mult_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.rand_mult)
}

// optional bytes tx_enc_keys = 4;
inline bool MoneroTransactionFinalAck::has_tx_enc_keys() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionFinalAck::set_has_tx_enc_keys() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionFinalAck::clear_has_tx_enc_keys() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionFinalAck::clear_tx_enc_keys() {
  if (tx_enc_keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_enc_keys_->clear();
  }
  clear_has_tx_enc_keys();
}
inline const ::std::string& MoneroTransactionFinalAck::tx_enc_keys() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return *tx_enc_keys_;
}
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const ::std::string& value) {
  set_has_tx_enc_keys();
  if (tx_enc_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_enc_keys_ = new ::std::string;
  }
  tx_enc_keys_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const char* value) {
  set_has_tx_enc_keys();
  if (tx_enc_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_enc_keys_ = new ::std::string;
  }
  tx_enc_keys_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline void MoneroTransactionFinalAck::set_tx_enc_keys(const void* value, size_t size) {
  set_has_tx_enc_keys();
  if (tx_enc_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_enc_keys_ = new ::std::string;
  }
  tx_enc_keys_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}
inline ::std::string* MoneroTransactionFinalAck::mutable_tx_enc_keys() {
  set_has_tx_enc_keys();
  if (tx_enc_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_enc_keys_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
  return tx_enc_keys_;
}
inline ::std::string* MoneroTransactionFinalAck::release_tx_enc_keys() {
  clear_has_tx_enc_keys();
  if (tx_enc_keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_enc_keys_;
    tx_enc_keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroTransactionFinalAck::set_allocated_tx_enc_keys(::std::string* tx_enc_keys) {
  if (tx_enc_keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_enc_keys_;
  }
  if (tx_enc_keys) {
    set_has_tx_enc_keys();
    tx_enc_keys_ = tx_enc_keys;
  } else {
    clear_has_tx_enc_keys();
    tx_enc_keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionFinalAck.tx_enc_keys)
}

// -------------------------------------------------------------------

// MoneroTransactionSignRequest

// optional .hw.trezor.messages.monero.MoneroTransactionInitRequest init = 1;
inline bool MoneroTransactionSignRequest::has_init() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_init() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroTransactionSignRequest::clear_has_init() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroTransactionSignRequest::clear_init() {
  if (init_ != NULL) init_->::hw::trezor::messages::monero::MoneroTransactionInitRequest::Clear();
  clear_has_init();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInitRequest& MoneroTransactionSignRequest::init() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.init)
  return init_ != NULL ? *init_ : *default_instance_->init_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest* MoneroTransactionSignRequest::mutable_init() {
  set_has_init();
  if (init_ == NULL) init_ = new ::hw::trezor::messages::monero::MoneroTransactionInitRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.init)
  return init_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInitRequest* MoneroTransactionSignRequest::release_init() {
  clear_has_init();
  ::hw::trezor::messages::monero::MoneroTransactionInitRequest* temp = init_;
  init_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_init(::hw::trezor::messages::monero::MoneroTransactionInitRequest* init) {
  delete init_;
  init_ = init;
  if (init) {
    set_has_init();
  } else {
    clear_has_init();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.init)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSetInputRequest set_input = 2;
inline bool MoneroTransactionSignRequest::has_set_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_set_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroTransactionSignRequest::clear_has_set_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroTransactionSignRequest::clear_set_input() {
  if (set_input_ != NULL) set_input_->::hw::trezor::messages::monero::MoneroTransactionSetInputRequest::Clear();
  clear_has_set_input();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest& MoneroTransactionSignRequest::set_input() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_input)
  return set_input_ != NULL ? *set_input_ : *default_instance_->set_input_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* MoneroTransactionSignRequest::mutable_set_input() {
  set_has_set_input();
  if (set_input_ == NULL) set_input_ = new ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_input)
  return set_input_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* MoneroTransactionSignRequest::release_set_input() {
  clear_has_set_input();
  ::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* temp = set_input_;
  set_input_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_set_input(::hw::trezor::messages::monero::MoneroTransactionSetInputRequest* set_input) {
  delete set_input_;
  set_input_ = set_input;
  if (set_input) {
    set_has_set_input();
  } else {
    clear_has_set_input();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_input)
}

// optional .hw.trezor.messages.monero.MoneroTransactionInputsPermutationRequest input_permutation = 3;
inline bool MoneroTransactionSignRequest::has_input_permutation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_input_permutation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroTransactionSignRequest::clear_has_input_permutation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroTransactionSignRequest::clear_input_permutation() {
  if (input_permutation_ != NULL) input_permutation_->::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest::Clear();
  clear_has_input_permutation();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest& MoneroTransactionSignRequest::input_permutation() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_permutation)
  return input_permutation_ != NULL ? *input_permutation_ : *default_instance_->input_permutation_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* MoneroTransactionSignRequest::mutable_input_permutation() {
  set_has_input_permutation();
  if (input_permutation_ == NULL) input_permutation_ = new ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_permutation)
  return input_permutation_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* MoneroTransactionSignRequest::release_input_permutation() {
  clear_has_input_permutation();
  ::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* temp = input_permutation_;
  input_permutation_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_input_permutation(::hw::trezor::messages::monero::MoneroTransactionInputsPermutationRequest* input_permutation) {
  delete input_permutation_;
  input_permutation_ = input_permutation;
  if (input_permutation) {
    set_has_input_permutation();
  } else {
    clear_has_input_permutation();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_permutation)
}

// optional .hw.trezor.messages.monero.MoneroTransactionInputViniRequest input_vini = 4;
inline bool MoneroTransactionSignRequest::has_input_vini() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_input_vini() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroTransactionSignRequest::clear_has_input_vini() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroTransactionSignRequest::clear_input_vini() {
  if (input_vini_ != NULL) input_vini_->::hw::trezor::messages::monero::MoneroTransactionInputViniRequest::Clear();
  clear_has_input_vini();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest& MoneroTransactionSignRequest::input_vini() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_vini)
  return input_vini_ != NULL ? *input_vini_ : *default_instance_->input_vini_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* MoneroTransactionSignRequest::mutable_input_vini() {
  set_has_input_vini();
  if (input_vini_ == NULL) input_vini_ = new ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_vini)
  return input_vini_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* MoneroTransactionSignRequest::release_input_vini() {
  clear_has_input_vini();
  ::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* temp = input_vini_;
  input_vini_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_input_vini(::hw::trezor::messages::monero::MoneroTransactionInputViniRequest* input_vini) {
  delete input_vini_;
  input_vini_ = input_vini;
  if (input_vini) {
    set_has_input_vini();
  } else {
    clear_has_input_vini();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.input_vini)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSetOutputRequest set_output = 5;
inline bool MoneroTransactionSignRequest::has_set_output() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_set_output() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneroTransactionSignRequest::clear_has_set_output() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneroTransactionSignRequest::clear_set_output() {
  if (set_output_ != NULL) set_output_->::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest::Clear();
  clear_has_set_output();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest& MoneroTransactionSignRequest::set_output() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_output)
  return set_output_ != NULL ? *set_output_ : *default_instance_->set_output_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* MoneroTransactionSignRequest::mutable_set_output() {
  set_has_set_output();
  if (set_output_ == NULL) set_output_ = new ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_output)
  return set_output_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* MoneroTransactionSignRequest::release_set_output() {
  clear_has_set_output();
  ::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* temp = set_output_;
  set_output_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_set_output(::hw::trezor::messages::monero::MoneroTransactionSetOutputRequest* set_output) {
  delete set_output_;
  set_output_ = set_output;
  if (set_output) {
    set_has_set_output();
  } else {
    clear_has_set_output();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.set_output)
}

// optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetRequest all_out_set = 6;
inline bool MoneroTransactionSignRequest::has_all_out_set() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_all_out_set() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneroTransactionSignRequest::clear_has_all_out_set() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneroTransactionSignRequest::clear_all_out_set() {
  if (all_out_set_ != NULL) all_out_set_->::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest::Clear();
  clear_has_all_out_set();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest& MoneroTransactionSignRequest::all_out_set() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.all_out_set)
  return all_out_set_ != NULL ? *all_out_set_ : *default_instance_->all_out_set_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* MoneroTransactionSignRequest::mutable_all_out_set() {
  set_has_all_out_set();
  if (all_out_set_ == NULL) all_out_set_ = new ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.all_out_set)
  return all_out_set_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* MoneroTransactionSignRequest::release_all_out_set() {
  clear_has_all_out_set();
  ::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* temp = all_out_set_;
  all_out_set_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_all_out_set(::hw::trezor::messages::monero::MoneroTransactionAllOutSetRequest* all_out_set) {
  delete all_out_set_;
  all_out_set_ = all_out_set;
  if (all_out_set) {
    set_has_all_out_set();
  } else {
    clear_has_all_out_set();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.all_out_set)
}

// optional .hw.trezor.messages.monero.MoneroTransactionMlsagDoneRequest mlsag_done = 7;
inline bool MoneroTransactionSignRequest::has_mlsag_done() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_mlsag_done() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoneroTransactionSignRequest::clear_has_mlsag_done() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoneroTransactionSignRequest::clear_mlsag_done() {
  if (mlsag_done_ != NULL) mlsag_done_->::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest::Clear();
  clear_has_mlsag_done();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest& MoneroTransactionSignRequest::mlsag_done() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.mlsag_done)
  return mlsag_done_ != NULL ? *mlsag_done_ : *default_instance_->mlsag_done_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* MoneroTransactionSignRequest::mutable_mlsag_done() {
  set_has_mlsag_done();
  if (mlsag_done_ == NULL) mlsag_done_ = new ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.mlsag_done)
  return mlsag_done_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* MoneroTransactionSignRequest::release_mlsag_done() {
  clear_has_mlsag_done();
  ::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* temp = mlsag_done_;
  mlsag_done_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_mlsag_done(::hw::trezor::messages::monero::MoneroTransactionMlsagDoneRequest* mlsag_done) {
  delete mlsag_done_;
  mlsag_done_ = mlsag_done;
  if (mlsag_done) {
    set_has_mlsag_done();
  } else {
    clear_has_mlsag_done();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.mlsag_done)
}

// optional .hw.trezor.messages.monero.MoneroTransactionSignInputRequest sign_input = 8;
inline bool MoneroTransactionSignRequest::has_sign_input() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_sign_input() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoneroTransactionSignRequest::clear_has_sign_input() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoneroTransactionSignRequest::clear_sign_input() {
  if (sign_input_ != NULL) sign_input_->::hw::trezor::messages::monero::MoneroTransactionSignInputRequest::Clear();
  clear_has_sign_input();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest& MoneroTransactionSignRequest::sign_input() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.sign_input)
  return sign_input_ != NULL ? *sign_input_ : *default_instance_->sign_input_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* MoneroTransactionSignRequest::mutable_sign_input() {
  set_has_sign_input();
  if (sign_input_ == NULL) sign_input_ = new ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.sign_input)
  return sign_input_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* MoneroTransactionSignRequest::release_sign_input() {
  clear_has_sign_input();
  ::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* temp = sign_input_;
  sign_input_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_sign_input(::hw::trezor::messages::monero::MoneroTransactionSignInputRequest* sign_input) {
  delete sign_input_;
  sign_input_ = sign_input;
  if (sign_input) {
    set_has_sign_input();
  } else {
    clear_has_sign_input();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.sign_input)
}

// optional .hw.trezor.messages.monero.MoneroTransactionFinalRequest final_msg = 9;
inline bool MoneroTransactionSignRequest::has_final_msg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoneroTransactionSignRequest::set_has_final_msg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoneroTransactionSignRequest::clear_has_final_msg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoneroTransactionSignRequest::clear_final_msg() {
  if (final_msg_ != NULL) final_msg_->::hw::trezor::messages::monero::MoneroTransactionFinalRequest::Clear();
  clear_has_final_msg();
}
inline const ::hw::trezor::messages::monero::MoneroTransactionFinalRequest& MoneroTransactionSignRequest::final_msg() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroTransactionSignRequest.final_msg)
  return final_msg_ != NULL ? *final_msg_ : *default_instance_->final_msg_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* MoneroTransactionSignRequest::mutable_final_msg() {
  set_has_final_msg();
  if (final_msg_ == NULL) final_msg_ = new ::hw::trezor::messages::monero::MoneroTransactionFinalRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroTransactionSignRequest.final_msg)
  return final_msg_;
}
inline ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* MoneroTransactionSignRequest::release_final_msg() {
  clear_has_final_msg();
  ::hw::trezor::messages::monero::MoneroTransactionFinalRequest* temp = final_msg_;
  final_msg_ = NULL;
  return temp;
}
inline void MoneroTransactionSignRequest::set_allocated_final_msg(::hw::trezor::messages::monero::MoneroTransactionFinalRequest* final_msg) {
  delete final_msg_;
  final_msg_ = final_msg;
  if (final_msg) {
    set_has_final_msg();
  } else {
    clear_has_final_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroTransactionSignRequest.final_msg)
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList

// optional uint32 account = 1;
inline bool MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_account() {
  account_ = 0u;
  clear_has_account();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::account() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
  return account_;
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_account(::google::protobuf::uint32 value) {
  set_has_account();
  account_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.account)
}

// repeated uint32 minor_indices = 2;
inline int MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices_size() const {
  return minor_indices_.size();
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::clear_minor_indices() {
  minor_indices_.Clear();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return minor_indices_.Get(index);
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::set_minor_indices(int index, ::google::protobuf::uint32 value) {
  minor_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline void MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::add_minor_indices(::google::protobuf::uint32 value) {
  minor_indices_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::minor_indices() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return minor_indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::mutable_minor_indices() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList.minor_indices)
  return &minor_indices_;
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitRequest

// optional uint64 num = 1;
inline bool MoneroKeyImageExportInitRequest::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageExportInitRequest::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageExportInitRequest::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageExportInitRequest::clear_num() {
  num_ = GOOGLE_ULONGLONG(0);
  clear_has_num();
}
inline ::google::protobuf::uint64 MoneroKeyImageExportInitRequest::num() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
  return num_;
}
inline void MoneroKeyImageExportInitRequest::set_num(::google::protobuf::uint64 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.num)
}

// optional bytes hash = 2;
inline bool MoneroKeyImageExportInitRequest::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageExportInitRequest::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroKeyImageExportInitRequest::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroKeyImageExportInitRequest::clear_hash() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& MoneroKeyImageExportInitRequest::hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return *hash_;
}
inline void MoneroKeyImageExportInitRequest::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline void MoneroKeyImageExportInitRequest::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline void MoneroKeyImageExportInitRequest::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}
inline ::std::string* MoneroKeyImageExportInitRequest::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
  return hash_;
}
inline ::std::string* MoneroKeyImageExportInitRequest::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageExportInitRequest::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.hash)
}

// repeated uint32 address_n = 3;
inline int MoneroKeyImageExportInitRequest::address_n_size() const {
  return address_n_.size();
}
inline void MoneroKeyImageExportInitRequest::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest::address_n(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return address_n_.Get(index);
}
inline void MoneroKeyImageExportInitRequest::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline void MoneroKeyImageExportInitRequest::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MoneroKeyImageExportInitRequest::address_n() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MoneroKeyImageExportInitRequest::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.address_n)
  return &address_n_;
}

// optional uint32 network_type = 4;
inline bool MoneroKeyImageExportInitRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroKeyImageExportInitRequest::set_has_network_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroKeyImageExportInitRequest::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroKeyImageExportInitRequest::clear_network_type() {
  network_type_ = 0u;
  clear_has_network_type();
}
inline ::google::protobuf::uint32 MoneroKeyImageExportInitRequest::network_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
  return network_type_;
}
inline void MoneroKeyImageExportInitRequest::set_network_type(::google::protobuf::uint32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.network_type)
}

// repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;
inline int MoneroKeyImageExportInitRequest::subs_size() const {
  return subs_.size();
}
inline void MoneroKeyImageExportInitRequest::clear_subs() {
  subs_.Clear();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList& MoneroKeyImageExportInitRequest::subs(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::mutable_subs(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Mutable(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList* MoneroKeyImageExportInitRequest::add_subs() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >&
MoneroKeyImageExportInitRequest::subs() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return subs_;
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList >*
MoneroKeyImageExportInitRequest::mutable_subs() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.subs)
  return &subs_;
}

// -------------------------------------------------------------------

// MoneroKeyImageExportInitAck

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest_MoneroTransferDetails

// optional bytes out_key = 1;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_out_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_has_out_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_has_out_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_out_key() {
  if (out_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_key_->clear();
  }
  clear_has_out_key();
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::out_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return *out_key_;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const ::std::string& value) {
  set_has_out_key();
  if (out_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_key_ = new ::std::string;
  }
  out_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const char* value) {
  set_has_out_key();
  if (out_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_key_ = new ::std::string;
  }
  out_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_out_key(const void* value, size_t size) {
  set_has_out_key();
  if (out_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_key_ = new ::std::string;
  }
  out_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_out_key() {
  set_has_out_key();
  if (out_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    out_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
  return out_key_;
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_out_key() {
  clear_has_out_key();
  if (out_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = out_key_;
    out_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_out_key(::std::string* out_key) {
  if (out_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete out_key_;
  }
  if (out_key) {
    set_has_out_key();
    out_key_ = out_key;
  } else {
    clear_has_out_key();
    out_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.out_key)
}

// optional bytes tx_pub_key = 2;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_tx_pub_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_has_tx_pub_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_has_tx_pub_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_tx_pub_key() {
  if (tx_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_pub_key_->clear();
  }
  clear_has_tx_pub_key();
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::tx_pub_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return *tx_pub_key_;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const ::std::string& value) {
  set_has_tx_pub_key();
  if (tx_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_pub_key_ = new ::std::string;
  }
  tx_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const char* value) {
  set_has_tx_pub_key();
  if (tx_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_pub_key_ = new ::std::string;
  }
  tx_pub_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_tx_pub_key(const void* value, size_t size) {
  set_has_tx_pub_key();
  if (tx_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_pub_key_ = new ::std::string;
  }
  tx_pub_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_tx_pub_key() {
  set_has_tx_pub_key();
  if (tx_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_pub_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
  return tx_pub_key_;
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::release_tx_pub_key() {
  clear_has_tx_pub_key();
  if (tx_pub_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_pub_key_;
    tx_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_allocated_tx_pub_key(::std::string* tx_pub_key) {
  if (tx_pub_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_pub_key_;
  }
  if (tx_pub_key) {
    set_has_tx_pub_key();
    tx_pub_key_ = tx_pub_key;
  } else {
    clear_has_tx_pub_key();
    tx_pub_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.tx_pub_key)
}

// repeated bytes additional_tx_pub_keys = 3;
inline int MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys_size() const {
  return additional_tx_pub_keys_.size();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_additional_tx_pub_keys() {
  additional_tx_pub_keys_.Clear();
}
inline const ::std::string& MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_.Get(index);
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_.Mutable(index);
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  additional_tx_pub_keys_.Mutable(index)->assign(value);
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const char* value) {
  additional_tx_pub_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_additional_tx_pub_keys(int index, const void* value, size_t size) {
  additional_tx_pub_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline ::std::string* MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys() {
  return additional_tx_pub_keys_.Add();
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const ::std::string& value) {
  additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const char* value) {
  additional_tx_pub_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::add_additional_tx_pub_keys(const void* value, size_t size) {
  additional_tx_pub_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::additional_tx_pub_keys() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return additional_tx_pub_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MoneroKeyImageSyncStepRequest_MoneroTransferDetails::mutable_additional_tx_pub_keys() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.additional_tx_pub_keys)
  return &additional_tx_pub_keys_;
}

// optional uint64 internal_output_index = 4;
inline bool MoneroKeyImageSyncStepRequest_MoneroTransferDetails::has_internal_output_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_has_internal_output_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_has_internal_output_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::clear_internal_output_index() {
  internal_output_index_ = GOOGLE_ULONGLONG(0);
  clear_has_internal_output_index();
}
inline ::google::protobuf::uint64 MoneroKeyImageSyncStepRequest_MoneroTransferDetails::internal_output_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
  return internal_output_index_;
}
inline void MoneroKeyImageSyncStepRequest_MoneroTransferDetails::set_internal_output_index(::google::protobuf::uint64 value) {
  set_has_internal_output_index();
  internal_output_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails.internal_output_index)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepRequest

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;
inline int MoneroKeyImageSyncStepRequest::tdis_size() const {
  return tdis_.size();
}
inline void MoneroKeyImageSyncStepRequest::clear_tdis() {
  tdis_.Clear();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails& MoneroKeyImageSyncStepRequest::tdis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::mutable_tdis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Mutable(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails* MoneroKeyImageSyncStepRequest::add_tdis() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >&
MoneroKeyImageSyncStepRequest::tdis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return tdis_;
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest_MoneroTransferDetails >*
MoneroKeyImageSyncStepRequest::mutable_tdis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.tdis)
  return &tdis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck_MoneroExportedKeyImage

// optional bytes iv = 1;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_iv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_has_iv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_has_iv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_iv() {
  if (iv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iv_->clear();
  }
  clear_has_iv();
}
inline const ::std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::iv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return *iv_;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const ::std::string& value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const char* value) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_iv(const void* value, size_t size) {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_iv() {
  set_has_iv();
  if (iv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iv_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
  return iv_;
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_iv() {
  clear_has_iv();
  if (iv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iv_;
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_iv(::std::string* iv) {
  if (iv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iv_;
  }
  if (iv) {
    set_has_iv();
    iv_ = iv;
  } else {
    clear_has_iv();
    iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.iv)
}

// optional bytes tag = 2;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::tag() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
  return *tag_;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
  return tag_;
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.tag)
}

// optional bytes blob = 3;
inline bool MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::has_blob() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_has_blob() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_has_blob() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::clear_blob() {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_->clear();
  }
  clear_has_blob();
}
inline const ::std::string& MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::blob() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return *blob_;
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const ::std::string& value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const char* value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_blob(const void* value, size_t size) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::mutable_blob() {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
  return blob_;
}
inline ::std::string* MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::release_blob() {
  clear_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blob_;
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::set_allocated_blob(::std::string* blob) {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_;
  }
  if (blob) {
    set_has_blob();
    blob_ = blob;
  } else {
    clear_has_blob();
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage.blob)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncStepAck

// repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;
inline int MoneroKeyImageSyncStepAck::kis_size() const {
  return kis_.size();
}
inline void MoneroKeyImageSyncStepAck::clear_kis() {
  kis_.Clear();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage& MoneroKeyImageSyncStepAck::kis(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Get(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::mutable_kis(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Mutable(index);
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage* MoneroKeyImageSyncStepAck::add_kis() {
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >&
MoneroKeyImageSyncStepAck::kis() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return kis_;
}
inline ::google::protobuf::RepeatedPtrField< ::hw::trezor::messages::monero::MoneroKeyImageSyncStepAck_MoneroExportedKeyImage >*
MoneroKeyImageSyncStepAck::mutable_kis() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.kis)
  return &kis_;
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalRequest

// -------------------------------------------------------------------

// MoneroKeyImageSyncFinalAck

// optional bytes enc_key = 1;
inline bool MoneroKeyImageSyncFinalAck::has_enc_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncFinalAck::set_has_enc_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageSyncFinalAck::clear_has_enc_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageSyncFinalAck::clear_enc_key() {
  if (enc_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enc_key_->clear();
  }
  clear_has_enc_key();
}
inline const ::std::string& MoneroKeyImageSyncFinalAck::enc_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return *enc_key_;
}
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const ::std::string& value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const char* value) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline void MoneroKeyImageSyncFinalAck::set_enc_key(const void* value, size_t size) {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enc_key_ = new ::std::string;
  }
  enc_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}
inline ::std::string* MoneroKeyImageSyncFinalAck::mutable_enc_key() {
  set_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enc_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
  return enc_key_;
}
inline ::std::string* MoneroKeyImageSyncFinalAck::release_enc_key() {
  clear_has_enc_key();
  if (enc_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enc_key_;
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MoneroKeyImageSyncFinalAck::set_allocated_enc_key(::std::string* enc_key) {
  if (enc_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enc_key_;
  }
  if (enc_key) {
    set_has_enc_key();
    enc_key_ = enc_key;
  } else {
    clear_has_enc_key();
    enc_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncFinalAck.enc_key)
}

// -------------------------------------------------------------------

// MoneroKeyImageSyncRequest

// optional .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest init = 1;
inline bool MoneroKeyImageSyncRequest::has_init() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneroKeyImageSyncRequest::set_has_init() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneroKeyImageSyncRequest::clear_has_init() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneroKeyImageSyncRequest::clear_init() {
  if (init_ != NULL) init_->::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest::Clear();
  clear_has_init();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest& MoneroKeyImageSyncRequest::init() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.init)
  return init_ != NULL ? *init_ : *default_instance_->init_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* MoneroKeyImageSyncRequest::mutable_init() {
  set_has_init();
  if (init_ == NULL) init_ = new ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.init)
  return init_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* MoneroKeyImageSyncRequest::release_init() {
  clear_has_init();
  ::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* temp = init_;
  init_ = NULL;
  return temp;
}
inline void MoneroKeyImageSyncRequest::set_allocated_init(::hw::trezor::messages::monero::MoneroKeyImageExportInitRequest* init) {
  delete init_;
  init_ = init;
  if (init) {
    set_has_init();
  } else {
    clear_has_init();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.init)
}

// optional .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest step = 2;
inline bool MoneroKeyImageSyncRequest::has_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneroKeyImageSyncRequest::set_has_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneroKeyImageSyncRequest::clear_has_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneroKeyImageSyncRequest::clear_step() {
  if (step_ != NULL) step_->::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest::Clear();
  clear_has_step();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest& MoneroKeyImageSyncRequest::step() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.step)
  return step_ != NULL ? *step_ : *default_instance_->step_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* MoneroKeyImageSyncRequest::mutable_step() {
  set_has_step();
  if (step_ == NULL) step_ = new ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.step)
  return step_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* MoneroKeyImageSyncRequest::release_step() {
  clear_has_step();
  ::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* temp = step_;
  step_ = NULL;
  return temp;
}
inline void MoneroKeyImageSyncRequest::set_allocated_step(::hw::trezor::messages::monero::MoneroKeyImageSyncStepRequest* step) {
  delete step_;
  step_ = step;
  if (step) {
    set_has_step();
  } else {
    clear_has_step();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.step)
}

// optional .hw.trezor.messages.monero.MoneroKeyImageSyncFinalRequest final_msg = 3;
inline bool MoneroKeyImageSyncRequest::has_final_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneroKeyImageSyncRequest::set_has_final_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneroKeyImageSyncRequest::clear_has_final_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneroKeyImageSyncRequest::clear_final_msg() {
  if (final_msg_ != NULL) final_msg_->::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest::Clear();
  clear_has_final_msg();
}
inline const ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest& MoneroKeyImageSyncRequest::final_msg() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.final_msg)
  return final_msg_ != NULL ? *final_msg_ : *default_instance_->final_msg_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* MoneroKeyImageSyncRequest::mutable_final_msg() {
  set_has_final_msg();
  if (final_msg_ == NULL) final_msg_ = new ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest;
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.final_msg)
  return final_msg_;
}
inline ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* MoneroKeyImageSyncRequest::release_final_msg() {
  clear_has_final_msg();
  ::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* temp = final_msg_;
  final_msg_ = NULL;
  return temp;
}
inline void MoneroKeyImageSyncRequest::set_allocated_final_msg(::hw::trezor::messages::monero::MoneroKeyImageSyncFinalRequest* final_msg) {
  delete final_msg_;
  final_msg_ = final_msg;
  if (final_msg) {
    set_has_final_msg();
  } else {
    clear_has_final_msg();
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.MoneroKeyImageSyncRequest.final_msg)
}

// -------------------------------------------------------------------

// DebugMoneroDiagRequest

// optional uint64 ins = 1;
inline bool DebugMoneroDiagRequest::has_ins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugMoneroDiagRequest::set_has_ins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugMoneroDiagRequest::clear_has_ins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugMoneroDiagRequest::clear_ins() {
  ins_ = GOOGLE_ULONGLONG(0);
  clear_has_ins();
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
  return ins_;
}
inline void DebugMoneroDiagRequest::set_ins(::google::protobuf::uint64 value) {
  set_has_ins();
  ins_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagRequest::has_p1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugMoneroDiagRequest::set_has_p1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugMoneroDiagRequest::clear_has_p1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugMoneroDiagRequest::clear_p1() {
  p1_ = GOOGLE_ULONGLONG(0);
  clear_has_p1();
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
  return p1_;
}
inline void DebugMoneroDiagRequest::set_p1(::google::protobuf::uint64 value) {
  set_has_p1();
  p1_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagRequest::has_p2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugMoneroDiagRequest::set_has_p2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugMoneroDiagRequest::clear_has_p2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugMoneroDiagRequest::clear_p2() {
  p2_ = GOOGLE_ULONGLONG(0);
  clear_has_p2();
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
  return p2_;
}
inline void DebugMoneroDiagRequest::set_p2(::google::protobuf::uint64 value) {
  set_has_p2();
  p2_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagRequest::pd_size() const {
  return pd_.size();
}
inline void DebugMoneroDiagRequest::clear_pd() {
  pd_.Clear();
}
inline ::google::protobuf::uint64 DebugMoneroDiagRequest::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return pd_.Get(index);
}
inline void DebugMoneroDiagRequest::set_pd(int index, ::google::protobuf::uint64 value) {
  pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline void DebugMoneroDiagRequest::add_pd(::google::protobuf::uint64 value) {
  pd_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DebugMoneroDiagRequest::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return pd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DebugMoneroDiagRequest::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagRequest.pd)
  return &pd_;
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagRequest::has_data1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugMoneroDiagRequest::set_has_data1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugMoneroDiagRequest::clear_has_data1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugMoneroDiagRequest::clear_data1() {
  if (data1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_->clear();
  }
  clear_has_data1();
}
inline const ::std::string& DebugMoneroDiagRequest::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return *data1_;
}
inline void DebugMoneroDiagRequest::set_data1(const ::std::string& value) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline void DebugMoneroDiagRequest::set_data1(const char* value) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline void DebugMoneroDiagRequest::set_data1(const void* value, size_t size) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}
inline ::std::string* DebugMoneroDiagRequest::mutable_data1() {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
  return data1_;
}
inline ::std::string* DebugMoneroDiagRequest::release_data1() {
  clear_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data1_;
    data1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DebugMoneroDiagRequest::set_allocated_data1(::std::string* data1) {
  if (data1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data1_;
  }
  if (data1) {
    set_has_data1();
    data1_ = data1;
  } else {
    clear_has_data1();
    data1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagRequest::has_data2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugMoneroDiagRequest::set_has_data2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DebugMoneroDiagRequest::clear_has_data2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DebugMoneroDiagRequest::clear_data2() {
  if (data2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_->clear();
  }
  clear_has_data2();
}
inline const ::std::string& DebugMoneroDiagRequest::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return *data2_;
}
inline void DebugMoneroDiagRequest::set_data2(const ::std::string& value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline void DebugMoneroDiagRequest::set_data2(const char* value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline void DebugMoneroDiagRequest::set_data2(const void* value, size_t size) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}
inline ::std::string* DebugMoneroDiagRequest::mutable_data2() {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
  return data2_;
}
inline ::std::string* DebugMoneroDiagRequest::release_data2() {
  clear_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data2_;
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DebugMoneroDiagRequest::set_allocated_data2(::std::string* data2) {
  if (data2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data2_;
  }
  if (data2) {
    set_has_data2();
    data2_ = data2;
  } else {
    clear_has_data2();
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagRequest.data2)
}

// -------------------------------------------------------------------

// DebugMoneroDiagAck

// optional uint64 ins = 1;
inline bool DebugMoneroDiagAck::has_ins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugMoneroDiagAck::set_has_ins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugMoneroDiagAck::clear_has_ins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugMoneroDiagAck::clear_ins() {
  ins_ = GOOGLE_ULONGLONG(0);
  clear_has_ins();
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::ins() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
  return ins_;
}
inline void DebugMoneroDiagAck::set_ins(::google::protobuf::uint64 value) {
  set_has_ins();
  ins_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.ins)
}

// optional uint64 p1 = 2;
inline bool DebugMoneroDiagAck::has_p1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugMoneroDiagAck::set_has_p1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugMoneroDiagAck::clear_has_p1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugMoneroDiagAck::clear_p1() {
  p1_ = GOOGLE_ULONGLONG(0);
  clear_has_p1();
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::p1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
  return p1_;
}
inline void DebugMoneroDiagAck::set_p1(::google::protobuf::uint64 value) {
  set_has_p1();
  p1_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p1)
}

// optional uint64 p2 = 3;
inline bool DebugMoneroDiagAck::has_p2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugMoneroDiagAck::set_has_p2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugMoneroDiagAck::clear_has_p2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugMoneroDiagAck::clear_p2() {
  p2_ = GOOGLE_ULONGLONG(0);
  clear_has_p2();
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::p2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
  return p2_;
}
inline void DebugMoneroDiagAck::set_p2(::google::protobuf::uint64 value) {
  set_has_p2();
  p2_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.p2)
}

// repeated uint64 pd = 4;
inline int DebugMoneroDiagAck::pd_size() const {
  return pd_.size();
}
inline void DebugMoneroDiagAck::clear_pd() {
  pd_.Clear();
}
inline ::google::protobuf::uint64 DebugMoneroDiagAck::pd(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return pd_.Get(index);
}
inline void DebugMoneroDiagAck::set_pd(int index, ::google::protobuf::uint64 value) {
  pd_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline void DebugMoneroDiagAck::add_pd(::google::protobuf::uint64 value) {
  pd_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DebugMoneroDiagAck::pd() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return pd_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DebugMoneroDiagAck::mutable_pd() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.monero.DebugMoneroDiagAck.pd)
  return &pd_;
}

// optional bytes data1 = 5;
inline bool DebugMoneroDiagAck::has_data1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugMoneroDiagAck::set_has_data1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugMoneroDiagAck::clear_has_data1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugMoneroDiagAck::clear_data1() {
  if (data1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_->clear();
  }
  clear_has_data1();
}
inline const ::std::string& DebugMoneroDiagAck::data1() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return *data1_;
}
inline void DebugMoneroDiagAck::set_data1(const ::std::string& value) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline void DebugMoneroDiagAck::set_data1(const char* value) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline void DebugMoneroDiagAck::set_data1(const void* value, size_t size) {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  data1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}
inline ::std::string* DebugMoneroDiagAck::mutable_data1() {
  set_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
  return data1_;
}
inline ::std::string* DebugMoneroDiagAck::release_data1() {
  clear_has_data1();
  if (data1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data1_;
    data1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DebugMoneroDiagAck::set_allocated_data1(::std::string* data1) {
  if (data1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data1_;
  }
  if (data1) {
    set_has_data1();
    data1_ = data1;
  } else {
    clear_has_data1();
    data1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data1)
}

// optional bytes data2 = 6;
inline bool DebugMoneroDiagAck::has_data2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugMoneroDiagAck::set_has_data2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DebugMoneroDiagAck::clear_has_data2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DebugMoneroDiagAck::clear_data2() {
  if (data2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_->clear();
  }
  clear_has_data2();
}
inline const ::std::string& DebugMoneroDiagAck::data2() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return *data2_;
}
inline void DebugMoneroDiagAck::set_data2(const ::std::string& value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline void DebugMoneroDiagAck::set_data2(const char* value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline void DebugMoneroDiagAck::set_data2(const void* value, size_t size) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  data2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}
inline ::std::string* DebugMoneroDiagAck::mutable_data2() {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
  return data2_;
}
inline ::std::string* DebugMoneroDiagAck::release_data2() {
  clear_has_data2();
  if (data2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data2_;
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DebugMoneroDiagAck::set_allocated_data2(::std::string* data2) {
  if (data2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data2_;
  }
  if (data2) {
    set_has_data2();
    data2_ = data2;
  } else {
    clear_has_data2();
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.monero.DebugMoneroDiagAck.data2)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace monero
}  // namespace messages
}  // namespace trezor
}  // namespace hw

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2dmonero_2eproto__INCLUDED
